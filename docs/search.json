[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Solutions Manual for An Advanced Guide to Trade Policy Analysis in R (3rd Edition)",
    "section": "",
    "text": "1 Introduction"
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Solutions Manual for An Advanced Guide to Trade Policy Analysis in R (3rd Edition)",
    "section": "1.1 Welcome",
    "text": "1.1 Welcome\n\n\n\n\nWelcome to the online solutions manual for for An Advanced Guide to Trade Policy Analysis (AGTPA).\nThis material provides a comprehensive explanation to reproduce the book’s results from Yotov et al. (2016) in R. We do not attempt to discuss the theory behind gravity models. The book thoroughly and the references cited through the chapters shall fill those details.\nThis manual points at two audiences:\n\nPeople who know R and are interested in learning about gravity models.\nPeople with no R knowledge who know gravity models theory.\n\nWe only assume that readers are familiar with linear regression and that they shall read Yotov et al. (2016) and Wickham and Grolemund (2016) alongside this material.\nWe replicated all the results from the book, obtained initially with Stata, in R as a way to contribute to Reproducible Research. R is free and available on almost every operating system. It is a beautiful tool for all statistical analyses."
  },
  {
    "objectID": "index.html#disclaimer",
    "href": "index.html#disclaimer",
    "title": "Solutions Manual for An Advanced Guide to Trade Policy Analysis in R (3rd Edition)",
    "section": "1.2 Disclaimer",
    "text": "1.2 Disclaimer\nThe views and opinions expressed in this thesis project are solely those of the author. They do not necessarily reflect the official position of the United Nations Economic and Social Commission for Asia and the Pacific or the Pontifical Catholic University of Chile."
  },
  {
    "objectID": "index.html#reproducing-agtpa-results-yourself",
    "href": "index.html#reproducing-agtpa-results-yourself",
    "title": "Solutions Manual for An Advanced Guide to Trade Policy Analysis in R (3rd Edition)",
    "section": "1.3 Reproducing AGTPA results yourself",
    "text": "1.3 Reproducing AGTPA results yourself\nWe created tradepolicy, an R package explicitly created to reproduce the results from AGTPA. It features its own functions to obtain the summary tables from the book, besides the datasets in R format.\nThe reader can get all the functions and datasets by running this line from RStudio:\n\ninstall.packages(\"tradepolicy\")\n\nAnother way to install the package is by using the remotes package and install it from GitHub:\n\nremotes::install_github(\"pachadotdev/tradepolicy\")"
  },
  {
    "objectID": "index.html#getting-the-most-out-of-this-material",
    "href": "index.html#getting-the-most-out-of-this-material",
    "title": "Solutions Manual for An Advanced Guide to Trade Policy Analysis in R (3rd Edition)",
    "section": "1.4 Getting the most out of this material",
    "text": "1.4 Getting the most out of this material\nThe reader can clone the GitHub repository to obtain the editable RMarkdown files:\ngit clone https://github.com/pachadotdev/tradepolicy.git\nPlease read Bryan, Hester, and STAT 545 TAs (2020) in case of questions about git or GitHub.\nThere’s a separate resource, ESCAP Online Training on Using R for Trade Analysis, which gives you a certificate if you finish the online training."
  },
  {
    "objectID": "index.html#acknowledgments",
    "href": "index.html#acknowledgments",
    "title": "Solutions Manual for An Advanced Guide to Trade Policy Analysis in R (3rd Edition)",
    "section": "1.5 Acknowledgments",
    "text": "1.5 Acknowledgments\nThis ebook improved noticeably from its early drafts thanks to valuable comments and corrections from:\n\nYoto Yotov (Drexel University).\nLuis Gutiérrez, Leonardo Jofré, Jessica Pavani, Constanza Prado, Vanessa Reinoso (Pontificia Universidad Católica de Chile).\nJinbo Hao, Alexey Kravchenko, Chence Sun (United Nations).\n\nFor the second (present) edition of the ebook, the communication and contributions to other projects by Laurent Berge (Université Bordeaux), Paulo F. Olivera (Ministério da Economia), Oliver Reiter (Wiener Institut für Internationale Wirtschaftsvergleiche), Hernan Robledo (P. U. Católica de Chile), and Matthieu Stigler (ETH Zurich) were crucial to improving the computation time results. The comments from Maria Semenova (United Nations) largely improved this second edition and helped to clarify different parts of the second chapter.\nEarlier versions of these solutions started during the development of the gravity R package, where Hrisyana Doytchinova’s comments and feedback were precious."
  },
  {
    "objectID": "index.html#changes-concerning-the-second-edition",
    "href": "index.html#changes-concerning-the-second-edition",
    "title": "Solutions Manual for An Advanced Guide to Trade Policy Analysis in R (3rd Edition)",
    "section": "1.6 Changes concerning the second edition",
    "text": "1.6 Changes concerning the second edition\nThe first edition was very conservative in avoiding external libraries (or packages). It only used the strict minimal packages such as dplyr for data cleaning and sandwich for clustered standard errors. We fitted all the models using base R, which was considerably slower than Stata, with a computation time around five to twenty times larger depending on the model link (or family) used.\nThe current edition uses fixest, which reduced the fitting time for all the models by around 95%. The book’s first edition takes around three hours to fit all the models and produce the final HTML. The same process now takes around ten minutes, and we hope these time efficiencies benefit the readers. An additional improvement was to add additional explanations to the codes and review all the text grammar based on the feedback received after publishing the first edition.\nWhile writing this second edition, a critical bug was detected and reported to improve fixest, which gave problems when having more than two fixed effects columns. The details for this are available on GitHub. The possibility of comparing with base R, reporting and getting fixes from the packages’ authors with transparent communication is a tremendous advantage from Open Source.\nAs Professor Yotov told this author once while writing his master’s thesis and the first edition: We should focus on the correctness of our results, then think about computational efficiency. He was right!"
  },
  {
    "objectID": "index.html#changes-concerning-the-third-edition",
    "href": "index.html#changes-concerning-the-third-edition",
    "title": "Solutions Manual for An Advanced Guide to Trade Policy Analysis in R (3rd Edition)",
    "section": "1.7 Changes concerning the third edition",
    "text": "1.7 Changes concerning the third edition\nThe second edition provided multiple internal enhancements to simplify package loading for the end user. Now we use a more direct approach to load the package and its datasets, as CRAN policies changes since we created this, and we also reflect some changes in the Tidyverse (i.e., such as the new pivot_ functions) and the fixest package.\nOn the technical side, now we use Quarto to streamline the ebook creation process."
  },
  {
    "objectID": "index.html#contact",
    "href": "index.html#contact",
    "title": "Solutions Manual for An Advanced Guide to Trade Policy Analysis in R (3rd Edition)",
    "section": "1.8 Contact",
    "text": "1.8 Contact\nPlease send me an email to m.sepulveda [at] mail.utoronto.ca if you have any questions."
  },
  {
    "objectID": "01-traditional-gravity.html#traditional-gravity-estimates",
    "href": "01-traditional-gravity.html#traditional-gravity-estimates",
    "title": "2  Partial equilibrium trade policy analysis with structural gravity",
    "section": "2.1 Traditional Gravity Estimates",
    "text": "2.1 Traditional Gravity Estimates\n\n2.1.1 Preparing the data\nIf the reader has never used R before, please check chapters 1 to 25 from Wickham and Grolemund (2016).\nIf the reader has only fitted a few regressions in R, without much practice on transforming and cleaning data before, please check chapters 5 and 18 from Wickham and Grolemund (2016).\nPlease see the note from page 42 in Yotov et al. (2016). It is a really important note, which tells us that we need to:\n\nFilter observations for a range of years (1986, 1990, 1994, 1998, 2002 and 2006)\nTransform some variables to logarithm scale (trade and dist) and create new variables from those in the original dataset\nRemove cases where both the exporter and the importer are the same\nDrop observations where the trade flow is zero\n\nUnlike Yotov et al. (2016), here we shall use a single dataset for all the applications and subset its columns depending on what we need. This decision kept the tradepolicy R package as light as possible.\nBefore conducting any data filtering or regression, we need to load the required packages.\n\n# dataset and summary functions\nlibrary(tradepolicy)\n\n# data transformation\nlibrary(dplyr)\nlibrary(tidyr)\n\n# regression\nlibrary(fixest)\n\nStep 1, including subsetting columns for this application, is straightforward.\n\nch1_application1 &lt;- agtpa_applications %&gt;%\n  select(exporter, importer, pair_id, year, trade, dist, cntg, lang, clny) %&gt;%\n  filter(year %in% seq(1986, 2006, 4))\n\nFor step 2, this can be divided in parts, starting with the log transformation of trade and distance.\n\nch1_application1 &lt;- ch1_application1 %&gt;%\n  mutate(\n    log_trade = log(trade),\n    log_dist = log(dist)\n  )\n\nContinuing step 2, we can now create the variables \\(Y_{i,t}\\) and \\(E_{i,t}\\) that appear on the OLS model equation in the book.\n\nch1_application1 &lt;- ch1_application1 %&gt;%\n  # Create Yit\n  group_by(exporter, year) %&gt;%\n  mutate(\n    y = sum(trade),\n    log_y = log(y)\n  ) %&gt;%\n  # Create Eit\n  group_by(importer, year) %&gt;%\n  mutate(\n    e = sum(trade),\n    log_e = log(e)\n  )\n\nThe OLS model with remoteness index needs both exporter and importer index, which grouping variables can create. We divide it into sub-steps: Replicate the computation of total exports, then the remoteness index for exporters, and finally the total imports with the corresponding remoteness index for importers.\n\nch1_application1 &lt;- ch1_application1 %&gt;%\n  # Replicate total_e\n  group_by(exporter, year) %&gt;%\n  mutate(total_e = sum(e)) %&gt;%\n  group_by(year) %&gt;%\n  mutate(total_e = max(total_e)) %&gt;%\n  # Replicate rem_exp\n  group_by(exporter, year) %&gt;%\n  mutate(\n    remoteness_exp = sum(dist * total_e / e),\n    log_remoteness_exp = log(remoteness_exp)\n  ) %&gt;%\n  # Replicate total_y\n  group_by(importer, year) %&gt;%\n  mutate(total_y = sum(y)) %&gt;%\n  group_by(year) %&gt;%\n  mutate(total_y = max(total_y)) %&gt;%\n  # Replicate rem_imp\n  group_by(importer, year) %&gt;%\n  mutate(\n    remoteness_imp = sum(dist / (y / total_y)),\n    log_remoteness_imp = log(remoteness_imp)\n  )\n\nTo create the variables for the OLS with Fixed Effects Model, we followed box #1 on page 44 from Yotov et al. (2016). We combine both exporter and importer variables with the year to create the fixed effects variables.\n\nch1_application1 &lt;- ch1_application1 %&gt;%\n  # This merges the columns exporter/importer with year\n  mutate(\n    exp_year = paste0(exporter, year),\n    imp_year = paste0(importer, year)\n  )\n\nThe addition of exporter/importer time fixed effects concludes step 2, and now we need to perform step 3.\n\nch1_application1 &lt;- ch1_application1 %&gt;%\n  filter(exporter != importer)\n\nSome cases require conducting step 4, and we will be explicit about it when needed.\n\n\n2.1.2 OLS estimation ignoring multilateral resistance terms\nThe general equation for this model is \\[\n\\begin{align}\n\\log X_{ij,t} =& \\:\\beta_0 + \\beta_1 DIST_{i,j} + \\beta_2 CNTG_{i,j} + \\beta_3 LANG_{i,j} + \\beta_4 CLNY_{i,j} + \\beta_5 \\log Y_{i,t} +\\\\\n\\text{ }& \\:\\beta_6 \\log E_{j,t} + \\varepsilon_{ij,t}.\n\\end{align}\n\\]\nPlease see page 41 in Yotov et al. (2016) for full detail of each variable.\nThe model for this case is straightforward, and in this case, we need to apply step 4 from the previous section to drop cases where the trade is zero.\n\nfit_ols &lt;- feols(\n  log_trade ~ log_dist + cntg + lang + clny + log_y + log_e,\n  data = filter(ch1_application1, trade &gt; 0)\n)\n\nsummary(fit_ols)\n\nOLS estimation, Dep. Var.: log_trade\nObservations: 25,689 \nStandard-errors: IID \n              Estimate Std. Error   t value   Pr(&gt;|t|)    \n(Intercept) -11.283080   0.151732 -74.36173  &lt; 2.2e-16 ***\nlog_dist     -1.001607   0.014159 -70.74094  &lt; 2.2e-16 ***\ncntg          0.573805   0.074427   7.70961 1.3076e-14 ***\nlang          0.801548   0.033748  23.75115  &lt; 2.2e-16 ***\nclny          0.734853   0.070387  10.44025  &lt; 2.2e-16 ***\nlog_y         1.190236   0.005402 220.32012  &lt; 2.2e-16 ***\nlog_e         0.907588   0.005577 162.72688  &lt; 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\nRMSE: 1.74274   Adj. R2: 0.758469\n\n\nThe employed function, feols(), does not carry a copy of its training data by default besides providing faster fitting for models with fixed effects. This is not the case in base R, where glm() outputs include this data, increasing the model’s size, but this does not affect the model’s predictions and can be changed as the user needs it (Zumel 2014).\nThe model is almost ready. We only need to stick to the methodology from Yotov et al. (2016) and cluster the standard errors by country pair (see the note on page 42, it is imperative).\n\nfit_ols &lt;- feols(\n  log_trade ~ log_dist + cntg + lang + clny + log_y + log_e,\n  data = filter(ch1_application1, trade &gt; 0),\n  cluster = ~pair_id\n)\n\nsummary(fit_ols)\n\nOLS estimation, Dep. Var.: log_trade\nObservations: 25,689 \nStandard-errors: Clustered (pair_id) \n              Estimate Std. Error   t value   Pr(&gt;|t|)    \n(Intercept) -11.283080   0.295827 -38.14076  &lt; 2.2e-16 ***\nlog_dist     -1.001607   0.027340 -36.63526  &lt; 2.2e-16 ***\ncntg          0.573805   0.184710   3.10652 1.9158e-03 ** \nlang          0.801548   0.082102   9.76286  &lt; 2.2e-16 ***\nclny          0.734853   0.144193   5.09632 3.7405e-07 ***\nlog_y         1.190236   0.009456 125.87160  &lt; 2.2e-16 ***\nlog_e         0.907588   0.009910  91.58459  &lt; 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\nRMSE: 1.74274   Adj. R2: 0.758469\n\n\nThe tradepolicy package provides functions to provide more informative summaries. Please read the documentation of the package and look for the tp_summary_app_1() function, it summarises the model in the exact way as reported in the book by providing:\n\nClustered standard errors.\nNumber of observations.\n\\(R^2\\) (if applicable).\nPresence (or absence) of exporter and exporter-time fixed effects.\nRESET test p-value.\n\nThese statistical results are returned as a list to keep it simple, which we can see for the model in the same format as reported in the book.\n\ntp_summary_app_1(\n  formula = log_trade ~ log_dist + cntg + lang + clny + log_y + log_e,\n  data = filter(ch1_application1, trade &gt; 0),\n  method = \"ols\"\n)\n\n|term        | estimate| std.error| statistic| p.value|\n|:-----------|--------:|---------:|---------:|-------:|\n|(Intercept) |  -11.283|     0.296|   -38.141|   0.000|\n|log_dist    |   -1.002|     0.027|   -36.635|   0.000|\n|cntg        |    0.574|     0.185|     3.107|   0.002|\n|lang        |    0.802|     0.082|     9.763|   0.000|\n|clny        |    0.735|     0.144|     5.096|   0.000|\n|log_y       |    1.190|     0.009|   125.872|   0.000|\n|log_e       |    0.908|     0.010|    91.585|   0.000|\n\n\n|  nobs| rsquared|etfe  |itfe  | reset_pval|\n|-----:|--------:|:-----|:-----|----------:|\n| 25689|    0.759|FALSE |FALSE |          0|\n\n\nPlease notice that the summary hides the exporter/importer fixed effects.\n\n\n2.1.3 OLS estimation controlling for multilateral resistance terms with remote indexes\nThe remoteness model adds variables to the OLS model. The general equation for this model is \\[\n\\begin{align}\n\\log X_{ij,t} =& \\:\\beta_0 + \\beta_1 DIST_{i,j} + \\beta_2 CNTG_{i,j} + \\beta_3 LANG_{i,j} + \\beta_4 CLNY_{i,j} + \\beta_5 \\log Y_{i,t} +\\\\\n\\text{ }& \\beta_6 \\log E_{j,t} + \\beta_7 \\log(REM\\_EXP_i,t) + \\beta_8 \\log(REM\\_IMP_i,t) + \\varepsilon_{ij,t}.\n\\end{align}\n\\]\nIn the equation above \\(REM\\_EXP\\) and \\(REM\\_IMP\\) are defined as \\[\n\\begin{align}\n\\log(REM\\_EXP_{i,t}) &= \\log \\left( \\sum_j \\frac{DIST_{i,j}}{E_{j,t} / Y_t} \\right) \\text{ and }\\\\\n\\log(REM\\_IMP_{j,t}) &= \\log \\left( \\sum_i \\frac{DIST_{i,j}}{Y_{i,t} / Y_t} \\right).\n\\end{align}\n\\]\nPlease see page 43 in Yotov et al. (2016) for full detail of each variable.\nOur approach follows box #1 on page 43 from Yotov et al. (2016). Fitting the regression is straightforward. It is just about adding more regressors to what we did in the last section, and we can create a list with a summary for the model.\n\ntp_summary_app_1(\n  formula = log_trade ~ log_dist + cntg + lang + clny + log_y + log_e +\n    log_remoteness_exp + log_remoteness_imp,\n  data = filter(ch1_application1, trade &gt; 0),\n  method = \"ols\"\n)\n\n|term               | estimate| std.error| statistic| p.value|\n|:------------------|--------:|---------:|---------:|-------:|\n|(Intercept)        |  -35.219|     1.986|   -17.731|   0.000|\n|log_dist           |   -1.185|     0.031|   -37.892|   0.000|\n|cntg               |    0.247|     0.177|     1.394|   0.164|\n|lang               |    0.739|     0.078|     9.429|   0.000|\n|clny               |    0.842|     0.150|     5.607|   0.000|\n|log_y              |    1.164|     0.009|   122.819|   0.000|\n|log_e              |    0.903|     0.010|    91.102|   0.000|\n|log_remoteness_exp |    0.972|     0.068|    14.251|   0.000|\n|log_remoteness_imp |    0.274|     0.060|     4.578|   0.000|\n\n\n|  nobs| rsquared|etfe  |itfe  | reset_pval|\n|-----:|--------:|:-----|:-----|----------:|\n| 25689|    0.765|FALSE |FALSE |          0|\n\n\n\n\n2.1.4 OLS estimation controlling for multilateral resistance terms with fixed effects\nThe general equation for this model is \\[\n\\begin{align}\n\\log X_{ij,t} =& \\: \\beta_1 \\log(DIST)_{i,j} + \\beta_2 CNTG_{i,j} + \\beta_3 LANG_{i,j} +\\\\\n\\text{ }& \\:\\beta_4 CLNY_{i,j} + \\pi_{i,t} + \\chi_{i,t} + \\varepsilon_{ij,t}.\n\\end{align}\n\\]\nWhere the added terms, concerning the OLS model, are \\(\\pi_{i,t}\\) and \\(\\chi_{i,t}\\) that account for exporter-time and importer-time fixed effects, respectively. See page 44 in Yotov et al. (2016) for full detail of each variable.\nWe can quickly generate a list as we did with the previous models. The only difference to the previous models is that in this case that the variables to the right of the “|” operator are the fixed effects, which are treated differently by the fixest package, which is used internally by the tradepolicy package, for faster model fitting.\nPlease notice that the summaries intentionally do not show fixed effects, because there are cases where we have thousands of fixed effects.\n\ntp_summary_app_1(\n  formula = log_trade ~ log_dist + cntg + lang + clny | exp_year + imp_year,\n  data = filter(ch1_application1, trade &gt; 0),\n  method = \"ols\"\n)\n\n|term     | estimate| std.error| statistic| p.value|\n|:--------|--------:|---------:|---------:|-------:|\n|log_dist |   -1.216|     0.038|   -31.841|   0.000|\n|cntg     |    0.223|     0.203|     1.100|   0.271|\n|lang     |    0.661|     0.082|     8.053|   0.000|\n|clny     |    0.670|     0.149|     4.487|   0.000|\n\n\n|  nobs| rsquared|etfe |itfe | reset_pval|\n|-----:|--------:|:----|:----|----------:|\n| 25689|    0.843|TRUE |TRUE |          0|\n\n\nThere is another difference when we compare feols() or fepois() against glm() in the presence of fixed effects, which we can explain with an example.\nIn the data used for the previous summary, we have \\(T\\) years (1986, 1990, 1994, 1998, 2002 and 2006). We could be interested in filtering for a single exporter and a single importer to fit the fixed effects model \\[\n\\log X_{t} = \\beta_1 \\log(DIST)_{i,j} + \\beta_2 CNTG_{i,j} + \\beta_3 LANG_{i,j} + \\beta_4 CLNY_{i,j} + \\sum_{u} \\beta_u FE_u + \\varepsilon_{ij,t},\n\\] where \\[\n\\begin{align*}\n&u \\in \\{1986, 1990, 1994, 1998, 2002, 2006\\} \\text{ and}\\cr\n&FE_u = \\begin{cases}\n1 & \\text {if } t = u \\cr\n0 & \\text{otherwise}.\n\\end{cases}\n\\end{align*}\n\\]\nWhen we use feols(), or any of the functions in the fixest package, a formula of the form \\(z \\sim x_1 + x_2 \\mid y\\) will estimate the model described in the previous equations.\nIf we do the same in base R, with glm(), the equivalent formula would be of the form \\(z \\sim 0 + x_1 + x_2 + y\\), otherwise base R estimates a model of the form \\(y_t = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + \\sum_u y_{u}\\), which means that not including a zero in the formula estimates an additional coefficient in the estimation which corresponds to a global intercept or the “grand mean”.\nOn the \\(\\beta_0\\) constant, it is tough to interpret with many-way fixed effects, and it is advised against reporting it.\n\n\n2.1.5 PPML estimation controlling for multilateral resistance terms with fixed effects\nThe general equation for this model is \\[\n\\begin{align}\nX_{ij,t} =& \\:\\exp\\left[\\beta_1 \\log(DIST)_{i,j} + \\beta_2 CNTG_{i,j} +\\right.\\\\\n\\text{ }& \\:\\left.\\beta_3 LANG_{i,j} + \\beta_4 CLNY_{i,j} + \\pi_{i,t} + \\chi_{i,t}\\right] \\times \\varepsilon_{ij,t}.\n\\end{align}\n\\]\nThe reason to compute this model, despite the lower speed compared to OLS, is that PPML is the only estimator perfectly consistent with the theoretical gravity model. By estimating with PPML, the fixed effects correspond precisely to the corresponding theoretical terms.\nThe data for this model is the same as for the fixed effects model, and one option in R is to use the fepois() function.\n\nfit_ppml &lt;- fepois(trade ~ log_dist + cntg + lang + clny | exp_year + imp_year,\n  data = ch1_application1,\n  cluster = ~pair_id\n)\n\nExactly as it was mentioned for feols(), fepois() shares the same differences regarding glm() objects.\nIf the reader decides to run this model and print the summary, they will notice that it does not report an \\(R^2\\) and displays an extensive fixed effect list. For PPML models, the \\(R^2\\) needs to be computed afterwards as Kendall’s correlation (or rank correlation) between the observed and predicted values. Please see Silva and Tenreyro (2006) for the details and the RESET test for PPML (GLM) models.\nBeware that software such as Stata requires additional libraries such as ppmlhdfe to report a correct \\(R^2\\) for the PPML model. What Stata shows is a reported pseudo-\\(R^2\\). To construct a proper \\(R^2\\) in R, tp_summary_app_1() takes the rank correlation between actual and predicted trade flows.\nWe can obtain a detailed list as in the previous examples.\n\ntp_summary_app_1(\n  formula = trade ~ log_dist + cntg + lang + clny | exp_year + imp_year,\n  data = ch1_application1,\n  method = \"ppml\"\n)\n\n|term     | estimate| std.error| statistic| p.value|\n|:--------|--------:|---------:|---------:|-------:|\n|log_dist |   -0.841|     0.032|   -26.169|   0.000|\n|cntg     |    0.437|     0.084|     5.182|   0.000|\n|lang     |    0.247|     0.078|     3.185|   0.001|\n|clny     |   -0.222|     0.118|    -1.886|   0.059|\n\n\n|  nobs| rsquared|etfe |itfe | reset_pval|\n|-----:|--------:|:----|:----|----------:|\n| 28152|    0.586|TRUE |TRUE |      0.647|"
  },
  {
    "objectID": "01-traditional-gravity.html#the-distance-puzzle-resolved",
    "href": "01-traditional-gravity.html#the-distance-puzzle-resolved",
    "title": "2  Partial equilibrium trade policy analysis with structural gravity",
    "section": "2.2 The “distance puzzle” resolved",
    "text": "2.2 The “distance puzzle” resolved\n\n2.2.1 Preparing the data\nPlease see the note from page 47 in Yotov et al. (2016). We need to proceed with similar steps as in the previous section.\nThe distance puzzle proposes the gravity specification \\[\n\\begin{align}\nX_{ij,t} =& \\:\\exp\\left[\\pi_{i,t} + \\chi_{i,t} + \\beta_1 \\log(DIST)_{i,j} + \\beta_2 CNTG_{i,j} + \\beta_3 LANG_{i,j}\\right]\\times\\\\\n\\text{ }& \\:\\exp\\left[\\beta_4 CLNY_{i,j} + \\beta_5 \\log(DIST\\_INTRA_{i,i})\\right] \\times \\varepsilon_{ij,t}.\n\\end{align}\n\\]\nThe difference concerning the last section is that now we need to separate the distance variable into multiple columns that account for discrete-time effects. The \\(\\beta_T\\) terms of the equation reflect this. Perhaps the easiest option is to transform the year into a text column and then use the pivot_wider() function.\nWe need to remove cases where the exporter is the same as the importer and cases where trade is zero for the OLS model. For the PPML models, we need to mark rows where the exporter and the importer are the same, and we need to create the same country column, which is also required to transform the distance variables as shown in box #1 in page 48 from Yotov et al. (2016).\nIn order to avoid creating two very similar datasets, we shall create one dataset to cover both OLS and PPML.\n\nch1_application2 &lt;- agtpa_applications %&gt;%\n  select(exporter, importer, pair_id, year, trade, dist, cntg, lang, clny) %&gt;%\n  # this filter covers both OLS and PPML\n  filter(year %in% seq(1986, 2006, 4)) %&gt;%\n  mutate(\n    # variables for both OLS and PPML\n    exp_year = paste0(exporter, year),\n    imp_year = paste0(importer, year),\n    year = paste0(\"log_dist_\", year),\n    log_trade = log(trade),\n    log_dist = log(dist),\n    smctry = ifelse(importer != exporter, 0, 1),\n\n    # PPML specific variables\n    log_dist_intra = log_dist * smctry,\n    intra_pair = ifelse(exporter == importer, exporter, \"inter\")\n  ) %&gt;%\n  pivot_wider(names_from = year, values_from = log_dist, values_fill = 0) %&gt;%\n  mutate(across(log_dist_1986:log_dist_2006, function(x) x * (1 - smctry)))\n\nThe across() function is a shortcut to avoid repetition, as in the following example, we show it for reference without computation.\n\nch1_application2 %&gt;%\n  mutate(\n    log_dist_1986 =  log_dist_1986 * (1 - smctry),\n    log_dist_1990 =  log_dist_1990 * (1 - smctry),\n\n    # repeat log_dist_T many_times for T = 1994, 1998, ...\n\n    log_dist_2006 =  log_dist_2006 * (1 - smctry)\n  )\n\nNote that the OLS model shall require filtering when we specify the model because we skipped filtering the cases where trade is equal to zero and both the importer and the exporter are the same. Because the solution for the “distance puzzle” implies different transformations and filters for the OLS and PPML cases, one possibility is to filter in the same summary functions.\n\n\n2.2.2 OLS solution for the “distance puzzle”\nThe gravity specification, which includes \\(\\pi_{i,t} + \\chi_{i,t}\\), means that we need to do something very similar to what we did in the last section.\nWith the data from above, the model specification is straightforward.\n\ntp_summary_app_2(\n  formula = log_trade ~ log_dist_1986 + log_dist_1990 + log_dist_1994 +\n    log_dist_1998 + log_dist_2002 + log_dist_2006 + cntg + lang + clny |\n    exp_year + imp_year,\n  data = filter(ch1_application2, importer != exporter, trade &gt; 0),\n  method = \"ols\"\n)\n\n|term          | estimate| std.error| statistic| p.value|\n|:-------------|--------:|---------:|---------:|-------:|\n|log_dist_1986 |   -1.168|     0.044|   -26.776|   0.000|\n|log_dist_1990 |   -1.155|     0.042|   -27.295|   0.000|\n|log_dist_1994 |   -1.211|     0.046|   -26.504|   0.000|\n|log_dist_1998 |   -1.248|     0.043|   -29.179|   0.000|\n|log_dist_2002 |   -1.241|     0.044|   -28.143|   0.000|\n|log_dist_2006 |   -1.261|     0.044|   -28.853|   0.000|\n|cntg          |    0.223|     0.203|     1.100|   0.271|\n|lang          |    0.661|     0.082|     8.056|   0.000|\n|clny          |    0.670|     0.149|     4.487|   0.000|\n\n\n|  nobs| pct_chg_log_dist| pcld_std_err| pcld_std_err_pval|intr  |csfe  |\n|-----:|----------------:|------------:|-----------------:|:-----|:-----|\n| 25689|             7.95|        3.698|             0.032|FALSE |FALSE |\n\n\n\n\n2.2.3 PPML solution for the “distance puzzle”\nThis model is very similar to the one specified in the PPML section from the last section. We can directly fit the model.\n\ntp_summary_app_2(\n  formula = trade ~ 0 + log_dist_1986 + log_dist_1990 + log_dist_1994 +\n    log_dist_1998 + log_dist_2002 + log_dist_2006 + cntg + lang + clny |\n    exp_year + imp_year,\n  data = filter(ch1_application2, importer != exporter),\n  method = \"ppml\"\n)\n\n|term          | estimate| std.error| statistic| p.value|\n|:-------------|--------:|---------:|---------:|-------:|\n|log_dist_1986 |   -0.859|     0.038|   -22.849|   0.000|\n|log_dist_1990 |   -0.834|     0.038|   -21.805|   0.000|\n|log_dist_1994 |   -0.835|     0.036|   -23.436|   0.000|\n|log_dist_1998 |   -0.847|     0.036|   -23.591|   0.000|\n|log_dist_2002 |   -0.848|     0.032|   -26.407|   0.000|\n|log_dist_2006 |   -0.836|     0.032|   -26.342|   0.000|\n|cntg          |    0.437|     0.084|     5.179|   0.000|\n|lang          |    0.248|     0.078|     3.185|   0.001|\n|clny          |   -0.222|     0.118|    -1.883|   0.060|\n\n\n|  nobs| pct_chg_log_dist| pcld_std_err| pcld_std_err_pval|intr  |csfe  |\n|-----:|----------------:|------------:|-----------------:|:-----|:-----|\n| 28152|            -2.75|        3.004|              0.36|FALSE |FALSE |\n\n\n\n\n2.2.4 Internal distance solution for the “distance puzzle”\nThis model requires us to add the internal distance variable to the PPML model and not filter the rows where the exporter and the importer are the same.\n\ntp_summary_app_2(\n  formula = trade ~ 0 + log_dist_1986 + log_dist_1990 + log_dist_1994 +\n    log_dist_1998 + log_dist_2002 + log_dist_2006 + cntg + lang + clny +\n    log_dist_intra | exp_year + imp_year,\n  data = ch1_application2,\n  method = \"ppml\"\n)\n\n|term           | estimate| std.error| statistic| p.value|\n|:--------------|--------:|---------:|---------:|-------:|\n|log_dist_1986  |   -0.980|     0.073|   -13.404|   0.000|\n|log_dist_1990  |   -0.940|     0.074|   -12.666|   0.000|\n|log_dist_1994  |   -0.915|     0.073|   -12.515|   0.000|\n|log_dist_1998  |   -0.887|     0.072|   -12.298|   0.000|\n|log_dist_2002  |   -0.884|     0.072|   -12.330|   0.000|\n|log_dist_2006  |   -0.872|     0.072|   -12.053|   0.000|\n|cntg           |    0.371|     0.142|     2.621|   0.009|\n|lang           |    0.337|     0.171|     1.976|   0.048|\n|clny           |    0.019|     0.159|     0.121|   0.904|\n|log_dist_intra |   -0.488|     0.102|    -4.779|   0.000|\n\n\n|  nobs| pct_chg_log_dist| pcld_std_err| pcld_std_err_pval|intr |csfe  |\n|-----:|----------------:|------------:|-----------------:|:----|:-----|\n| 28566|          -10.965|        1.058|                 0|TRUE |FALSE |\n\n\n\n\n2.2.5 Internal distance and home bias solution for the “distance puzzle”\nThis model requires us to add the same country variable to the internal distance model and repeat the rest of the steps from the last section.\n\ntp_summary_app_2(\n  formula = trade ~ log_dist_1986 + log_dist_1990 + log_dist_1994 +\n    log_dist_1998 + log_dist_2002 + log_dist_2006 + cntg + lang + clny +\n    log_dist_intra + smctry | exp_year + imp_year,\n  data = ch1_application2,\n  method = \"ppml\"\n)\n\n|term           | estimate| std.error| statistic| p.value|\n|:--------------|--------:|---------:|---------:|-------:|\n|log_dist_1986  |   -0.857|     0.064|   -13.476|   0.000|\n|log_dist_1990  |   -0.819|     0.064|   -12.748|   0.000|\n|log_dist_1994  |   -0.796|     0.064|   -12.349|   0.000|\n|log_dist_1998  |   -0.770|     0.064|   -12.040|   0.000|\n|log_dist_2002  |   -0.767|     0.064|   -12.060|   0.000|\n|log_dist_2006  |   -0.754|     0.063|   -11.950|   0.000|\n|cntg           |    0.574|     0.157|     3.645|   0.000|\n|lang           |    0.352|     0.139|     2.534|   0.011|\n|clny           |    0.027|     0.127|     0.212|   0.832|\n|log_dist_intra |   -0.602|     0.111|    -5.437|   0.000|\n|smctry         |    1.689|     0.582|     2.901|   0.004|\n\n\n|  nobs| pct_chg_log_dist| pcld_std_err| pcld_std_err_pval|intr |csfe  |\n|-----:|----------------:|------------:|-----------------:|:----|:-----|\n| 28566|          -11.969|        1.173|                 0|TRUE |FALSE |\n\n\n\n\n2.2.6 Fixed effects solution for the “distance puzzle”\nThis model requires us to remove the internal distance and same country variables from the last model and include the internal pair variable to account for the intra-national fixed effects.\n\ntp_summary_app_2(\n  formula = trade ~ 0 + log_dist_1986 + log_dist_1990 + log_dist_1994 +\n    log_dist_1998 + log_dist_2002 + log_dist_2006 + cntg + lang + clny +\n    intra_pair | exp_year + imp_year,\n  data = ch1_application2,\n  method = \"ppml\"\n)\n\nThe variable 'intra_pairZAF' has been removed because of collinearity (see $collin.var).\n\n\n|term          | estimate| std.error| statistic| p.value|\n|:-------------|--------:|---------:|---------:|-------:|\n|log_dist_1986 |   -0.910|     0.033|   -27.738|   0.000|\n|log_dist_1990 |   -0.879|     0.033|   -26.953|   0.000|\n|log_dist_1994 |   -0.860|     0.032|   -26.573|   0.000|\n|log_dist_1998 |   -0.833|     0.032|   -25.889|   0.000|\n|log_dist_2002 |   -0.829|     0.033|   -25.490|   0.000|\n|log_dist_2006 |   -0.811|     0.033|   -24.916|   0.000|\n|cntg          |    0.442|     0.083|     5.329|   0.000|\n|lang          |    0.241|     0.077|     3.114|   0.002|\n|clny          |   -0.220|     0.118|    -1.861|   0.063|\n\n\n|  nobs| pct_chg_log_dist| pcld_std_err| pcld_std_err_pval|intr |csfe |\n|-----:|----------------:|------------:|-----------------:|:----|:----|\n| 28566|          -10.931|        0.769|                 0|TRUE |TRUE |"
  },
  {
    "objectID": "01-traditional-gravity.html#regional-trade-agreements-effects",
    "href": "01-traditional-gravity.html#regional-trade-agreements-effects",
    "title": "2  Partial equilibrium trade policy analysis with structural gravity",
    "section": "2.3 Regional trade agreements effects",
    "text": "2.3 Regional trade agreements effects\n\n2.3.1 Preparing the data\nThis model specification includes gravity covariates, including importer-time and exporter-time fixed effects, as in the equation\n\\[\n\\begin{align}\nX_{ij,t} =& \\:\\exp\\left[\\pi_{i,t} + \\chi_{i,t} + \\beta_1 \\log(DIST)_{i,j} + \\beta_2 CNTG_{i,j} + \\beta_3 LANG_{i,j} +\\right.\\\\\n\\text{ }& \\:\\left.\\beta_4 CLNY_{i,j} + \\beta_5 RTA_{ij,t}\\right] \\times \\varepsilon_{ij,t}.\n\\end{align}\n\\]\nIn comparison to the previous examples, we need to create additional variables to include fixed effects that account for the observations where the exporter and the importer are the same. These variables are internal border, internal dyad and internal borders for different years.\nThe direct way of obtaining the desired variables is similar to what we did in the previous sections.\n\nch1_application3 &lt;- agtpa_applications %&gt;%\n  filter(year %in% seq(1986, 2006, 4)) %&gt;%\n  mutate(\n    exp_year = paste0(exporter, year),\n    imp_year = paste0(importer, year),\n    year = paste0(\"intl_border_\", year),\n    log_trade = log(trade),\n    log_dist = log(dist),\n    intl_brdr = ifelse(exporter == importer, pair_id, \"inter\"),\n    intl_brdr_2 = ifelse(exporter == importer, 0, 1),\n    pair_id_2 = ifelse(exporter == importer, \"0-intra\", pair_id)\n  ) %&gt;%\n  pivot_wider(names_from = year, values_from = intl_brdr_2, values_fill = 0)\n\nNotice that we used “0-intra” and not just “intra” because the rest of the observations in the internal dyads are numbers 1, …, N, and R internals shall consider “0-intra” as the reference factor for being the first item when it orders the unique observations alphabetically. Also, observe the order of the resulting table, the pivoting of the table will put “0-intra” as the first row for the first exporter-importer dyad. This makes the difference between the expected or other behaviours in the next chapter.\nIn addition, we need to create the variable containing the trade sum to filter the cases where the sum by dyad is zero.\n\nch1_application3 &lt;- ch1_application3 %&gt;%\n  group_by(pair_id) %&gt;%\n  mutate(sum_trade = sum(trade)) %&gt;%\n  ungroup()\n\n\n\n2.3.2 OLS standard RTA estimates with international trade only\nThe gravity specification, which includes \\(\\pi_{i,t} + \\chi_{i,t}\\), means that we need to do something very similar to what we did in the last section.\nWith the data from above, the model specification is straightforward.\n\ntp_summary_app_3(\n  formula = log_trade ~ log_dist + cntg + lang + clny + rta | exp_year +\n    imp_year,\n  data = filter(ch1_application3, trade &gt; 0, importer != exporter),\n  method = \"ols\"\n)\n\n|term     | estimate| std.error| statistic| p.value|\n|:--------|--------:|---------:|---------:|-------:|\n|log_dist |   -1.216|     0.039|   -31.180|   0.000|\n|cntg     |    0.223|     0.203|     1.099|   0.272|\n|lang     |    0.661|     0.082|     8.045|   0.000|\n|clny     |    0.670|     0.149|     4.487|   0.000|\n|rta      |   -0.004|     0.054|    -0.081|   0.935|\n\n\n|  nobs| total_rta_effect| trta_std_err| trta_std_err_pval|intr  |\n|-----:|----------------:|------------:|-----------------:|:-----|\n| 25689|           -0.004|        0.053|             0.934|FALSE |\n\n\n\n\n2.3.3 PPML standard RTA estimates with international trade only\nThe model specification is very similar to OLS, and we only need to change the method specified in the function.\n\ntp_summary_app_3(\n  formula = trade ~ log_dist + cntg + lang + clny + rta | exp_year + imp_year,\n  data = filter(ch1_application3, importer != exporter),\n  method = \"ppml\"\n)\n\n|term     | estimate| std.error| statistic| p.value|\n|:--------|--------:|---------:|---------:|-------:|\n|log_dist |   -0.822|     0.031|   -26.125|   0.000|\n|cntg     |    0.416|     0.084|     4.944|   0.000|\n|lang     |    0.250|     0.078|     3.211|   0.001|\n|clny     |   -0.205|     0.116|    -1.770|   0.077|\n|rta      |    0.191|     0.067|     2.855|   0.004|\n\n\n|  nobs| total_rta_effect| trta_std_err| trta_std_err_pval|intr  |\n|-----:|----------------:|------------:|-----------------:|:-----|\n| 28152|            0.191|        0.066|             0.004|FALSE |\n\n\n\n\n2.3.4 Addressing potential domestic trade diversion\nThe model specification is quite the same as PPML. We only need to add the international border variable but use the entire dataset instead of removing rows where the importer and the exporter are the same.\n\ntp_summary_app_3(\n  formula = trade ~ log_dist + cntg + lang + clny + rta | exp_year + imp_year +\n    intl_brdr,\n  data = ch1_application3,\n  method = \"ppml\"\n)\n\n|term     | estimate| std.error| statistic| p.value|\n|:--------|--------:|---------:|---------:|-------:|\n|log_dist |   -0.800|     0.031|   -26.025|   0.000|\n|cntg     |    0.393|     0.080|     4.906|   0.000|\n|lang     |    0.244|     0.078|     3.111|   0.002|\n|clny     |   -0.182|     0.115|    -1.581|   0.114|\n|rta      |    0.409|     0.070|     5.841|   0.000|\n\n\n|  nobs| total_rta_effect| trta_std_err| trta_std_err_pval|intr  |\n|-----:|----------------:|------------:|-----------------:|:-----|\n| 28566|            0.409|        0.069|                 0|FALSE |\n\n\n\n\n2.3.5 Addressing potential endogeneity of RTAs\nThe model specification includes the RTA variable and the exporter-time, importer-time and internal dyad fixed effects to account for domestic trade.\n\ntp_summary_app_3(\n  formula = trade ~ rta | exp_year + imp_year + pair_id_2,\n  data = filter(ch1_application3, sum_trade &gt; 0),\n  method = \"ppml\"\n)\n\n|term | estimate| std.error| statistic| p.value|\n|:----|--------:|---------:|---------:|-------:|\n|rta  |    0.557|     0.108|     5.138|       0|\n\n\n|  nobs| total_rta_effect| trta_std_err| trta_std_err_pval|intr  |\n|-----:|----------------:|------------:|-----------------:|:-----|\n| 28482|            0.557|        0.102|                 0|FALSE |\n\n\n\n\n2.3.6 Testing for potential “reverse causality” between trade and RTAs\nWe need to modify the previous model to include the forward lagged RTA variable (by four years) and consider where the trade sum is larger than zero.\n\ntp_summary_app_3(\n  formula = trade ~ rta + rta_lead4 | exp_year + imp_year + pair_id_2,\n  data = filter(ch1_application3, sum_trade &gt; 0),\n  method = \"ppml\"\n)\n\n|term      | estimate| std.error| statistic| p.value|\n|:---------|--------:|---------:|---------:|-------:|\n|rta       |    0.520|     0.091|     5.709|   0.000|\n|rta_lead4 |    0.077|     0.098|     0.792|   0.428|\n\n\n|  nobs| total_rta_effect| trta_std_err| trta_std_err_pval|intr  |\n|-----:|----------------:|------------:|-----------------:|:-----|\n| 28482|            0.597|        0.138|                 0|FALSE |\n\n\n\n\n2.3.7 Addressing potential non-linear and phasing-in effects of RTAs\nInstead of future-lagged RTA variables, as in the previous model, we modify the previous model and include the RTA backwards lagged variables instead.\n\ntp_summary_app_3(\n  formula = trade ~ rta + rta_lag4 + rta_lag8 + rta_lag12 | exp_year +\n    imp_year + pair_id_2,\n  data = filter(ch1_application3, sum_trade &gt; 0),\n  method = \"ppml\"\n)\n\n|term      | estimate| std.error| statistic| p.value|\n|:---------|--------:|---------:|---------:|-------:|\n|rta       |    0.291|     0.095|     3.081|   0.002|\n|rta_lag4  |    0.414|     0.071|     5.798|   0.000|\n|rta_lag8  |    0.169|     0.046|     3.688|   0.000|\n|rta_lag12 |    0.119|     0.032|     3.729|   0.000|\n\n\n|  nobs| total_rta_effect| trta_std_err| trta_std_err_pval|intr  |\n|-----:|----------------:|------------:|-----------------:|:-----|\n| 28482|            0.993|        0.094|                 0|FALSE |\n\n\n\n\n2.3.8 Addressing globalization effects\nIn addition to the previous model, we include the international borders on different years besides the lagged RTAs.\n\ntp_summary_app_3(\n  formula = trade ~ rta + rta_lag4 + rta_lag8 + rta_lag12 + intl_border_1986 +\n    intl_border_1990 + intl_border_1994 + intl_border_1998 + intl_border_2002 |\n    exp_year + imp_year + pair_id_2,\n  data = filter(ch1_application3, sum_trade &gt; 0),\n  method = \"ppml\"\n)\n\n|term             | estimate| std.error| statistic| p.value|\n|:----------------|--------:|---------:|---------:|-------:|\n|rta              |    0.116|     0.092|     1.258|   0.209|\n|rta_lag4         |    0.288|     0.065|     4.399|   0.000|\n|rta_lag8         |    0.069|     0.051|     1.356|   0.175|\n|rta_lag12        |    0.002|     0.031|     0.076|   0.939|\n|intl_border_1986 |   -0.706|     0.051|   -13.917|   0.000|\n|intl_border_1990 |   -0.480|     0.046|   -10.541|   0.000|\n|intl_border_1994 |   -0.367|     0.035|   -10.327|   0.000|\n|intl_border_1998 |   -0.158|     0.025|    -6.405|   0.000|\n|intl_border_2002 |   -0.141|     0.018|    -7.867|   0.000|\n\n\n|  nobs| total_rta_effect| trta_std_err| trta_std_err_pval|intr  |\n|-----:|----------------:|------------:|-----------------:|:-----|\n| 28482|            0.475|        0.109|                 0|FALSE |"
  },
  {
    "objectID": "02-general-equilibrium.html#trade-without-borders",
    "href": "02-general-equilibrium.html#trade-without-borders",
    "title": "3  General equilibrium trade policy analysis with structural gravity",
    "section": "3.1 Trade without borders",
    "text": "3.1 Trade without borders\n\n3.1.1 Initial data\nUnlike the previous chapter, we shall proceed by alternating both data transforming and regressions. In the previous chapter, it was possible first to process the datasets and then fit the regressions, but here we need the regressions’ output to create new variables. In any case, we will follow quite similar steps to the last chapter.\nTo do what is shown in box #1 from page 104 in Yotov et al. (2016), we need to convert “DEU” in both exporter and importer columns to “0-DEU” so that the software sets it as the reference factor (i.e., “0-DEU” will be listed before any text string starting with a letter). The book uses “ZZZ,” but in R, “ZZZ” will not be treated as the reference factor, for which case we could have used “AAA.” It is important to mention that box #1 does not show a previous step to filter observations for 2006, which is mentioned on page 103.\nBefore conducting any data filtering or regression, we need to load the required packages.\n\n# dataset and summary functions\nlibrary(tradepolicy)\n\n# data transformation\nlibrary(dplyr)\nlibrary(tidyr)\n\n# regression\nlibrary(fixest)\n\n# plots\nlibrary(ggplot2)\n\nWe start by defining some parameters to simplify the code. The value for the elasticity of substitution, \\(\\sigma = 7\\), used to set the convergence criteria is taken from the literature. There is an explanation in the original Stata code.\n\nref_country &lt;- \"DEU\"\nref_country0 &lt;- paste0(\"0-\", ref_country)\nsigma &lt;- 7\nmax_dif &lt;- 1\nsd_dif &lt;- 1\nchange_price_i_old &lt;- 0\n\nIt is imperative to arrange the table by importers. Otherwise, there is a difference in the estimated fixed effects that changes the factory prices in the last figure from this section, and here the aim is to fully replicate the two figures from this section in the book. We mentioned this in the RTA effects section from the previous chapter.\n\nch2_application1 &lt;- agtpa_applications %&gt;%\n  select(exporter, importer, pair_id, year, trade, dist, cntg, lang, clny) %&gt;%\n  filter(year == 2006) %&gt;%\n  mutate(\n    log_dist = log(dist),\n    intl = ifelse(exporter != importer, 1, 0),\n    exporter = ifelse(exporter == ref_country, ref_country0, exporter),\n    importer = ifelse(importer == ref_country, ref_country0, importer)\n  ) %&gt;%\n  arrange(importer) %&gt;%\n  # Create Yit\n  group_by(exporter) %&gt;%\n  mutate(y = sum(trade, na.rm = T)) %&gt;%\n  # Create Eit\n  group_by(importer) %&gt;%\n  mutate(e = sum(trade, na.rm = T)) %&gt;%\n  # Create Er\n  ungroup() %&gt;%\n  mutate(e_r = max(ifelse(importer == ref_country0, e, NA), na.rm = T))\n\n\n\n3.1.2 Step I: Solve the baseline model\nWe start by fitting the model\n\\[\n\\begin{align}\nX_{ij,t} =& \\:\\exp\\left[\\pi_{i,t} + \\chi_{i,t} + \\beta_1 \\log(DIST)_{i,j} + \\beta_2 CNTG_{i,j} + \\beta_3 INTL_{i,j}\\right] \\times \\varepsilon_{ij,t}.\n\\end{align}\n\\]\nWith the data from above, the model specification is straightforward.\n\nfit_baseline_app1 &lt;- fepois(\n  trade ~ log_dist + cntg + intl | exporter + importer,\n  data = ch2_application1,\n  glm.iter = 500\n)\n\nWith the estimated model, we can proceed as in box #1 from page 105 in Yotov et al. (2016) to construct the variables for exporter and importer fixed effects. This step is very different compared to Stata.\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  mutate(\n    fe_exporter_bln = fixef(fit_baseline_app1)$exporter[exporter],\n    fe_importer_bln = fixef(fit_baseline_app1)$importer[importer]\n  )\n\nStill following box #1, we need to compute the variables of bilateral trade costs and multilateral resistances.\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  mutate(\n    tij_bln = exp(fit_baseline_app1$coefficients[\"log_dist\"] * log_dist +\n      fit_baseline_app1$coefficients[\"cntg\"] * cntg +\n      fit_baseline_app1$coefficients[\"intl\"] * intl),\n\n    # outward multilateral resistance (omr)\n    omr_bln = y * (e_r / exp(fe_exporter_bln)),\n\n    # inward multilateral resistance (imr)\n    imr_bln = e / (exp(fe_importer_bln) * e_r)\n  )\n\nTo complete this estimation stage, we need to create a column with the estimated international trade for given output and expenditures. We start by adding a column with the estimated trade for the baseline model, and then we group by the exporter and summarise to obtain the required column \\(\\xi\\)-baseline.\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  mutate(tradehat_bln = predict(fit_baseline_app1, ch2_application1)) %&gt;%\n  group_by(exporter) %&gt;%\n  mutate(xi_bln = sum(tradehat_bln * (exporter != importer), na.rm = T)) %&gt;%\n  ungroup()\n\n\n\n3.1.3 Step II: Define a counterfactual scenario\nBox #2 from page 105 in Yotov et al. (2016) proposes two alternatives to define the counterfactual scenario of removing international borders. The first alternative is to eliminate the border variable and generate the logged trade costs used in the constraint.\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  mutate(\n    tij_cfl = exp(fit_baseline_app1$coefficients[\"log_dist\"] * log_dist +\n      fit_baseline_app1$coefficients[\"cntg\"] * cntg)\n  )\n\nThe second alternative is to define a new counterfactual border variable. We only show this equivalent case without computation.\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  mutate(\n    intl_cfl = 0,\n    tij_bln = exp(fit_baseline_app1$coefficients[\"log_dist\"] * log_dist +\n      fit_baseline_app1$coefficients[\"cntg\"] * cntg +\n      fit_baseline_app1$coefficients[\"intl\"] * intl_cfl)\n  )\n\n\n\n3.1.4 Step III: Solve the counterfactual model\nWe need to fit a model similar to the model from step I, the constrained gravity model, where \\(\\pi_{j,t}\\) and \\(\\chi_{j,t}\\) are altered as in the equation\n\\[\n\\begin{align}\nX_{ij,t} =& \\:\\exp\\left[\\pi_{i,t}^{CFL} + \\chi_{i,t}^{CFL} + \\beta_1 \\log(DIST)_{i,j} + \\beta_2 CNTG_{i,j} + \\beta_3 INTL_{i,j}\\right] \\times \\varepsilon_{ij,t}.\n\\end{align}\n\\]\nBox #1 from page 106 in Yotov et al. (2016) estimates the constrained gravity model with the PPML estimator using an offset argument, which is straightforward in R.\n\nfit_counterfactual_app1 &lt;- fepois(\n  trade ~ 0 | exporter + importer,\n  data = ch2_application1,\n  offset = ~ log(tij_cfl),\n  glm.iter = 500\n)\n\nAs in the previous chapter, we need to extract the fixed effects.\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  mutate(\n    fe_exporter_cfl = fixef(fit_counterfactual_app1)$exporter[exporter],\n    fe_importer_cfl = fixef(fit_counterfactual_app1)$importer[importer]\n  )\n\nNow we go for Box #2 from page 106 in Yotov et al. (2016), where the authors obtain the bilateral trade costs and multilateral resistances variables.\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  mutate(\n    # outward multilateral resistance (omr)\n    omr_cfl = y * (e_r / exp(fe_exporter_cfl)),\n\n    # inward multilateral resistance (imr)\n    imr_cfl = e / (exp(fe_importer_cfl) * e_r)\n  )\n\nBox #2 also shows how to compute trade’s conditional general equilibrium effects, similar to what we did in step I.\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  mutate(tradehat_cfl = predict(fit_counterfactual_app1, ch2_application1)) %&gt;%\n  group_by(exporter) %&gt;%\n  mutate(xi_cfl = sum(tradehat_cfl * (exporter != importer), na.rm = T)) %&gt;%\n  ungroup()\n\nBox #1 from page 107 in Yotov et al. (2016) can be simplified with R code. To construct the iterative procedure to converge to full endowment general equilibrium effects, we start by creating the required columns and parameters so that we will deviate from the original approach.\nWe start computing the change in bilateral trade costs (changes in \\(t_{ij}\\)) and trade deficit or surplus (\\(phi\\)).\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  mutate(\n    change_tij = tij_cfl / tij_bln,\n    phi = ifelse(importer == exporter, e / y, 0)\n  ) %&gt;%\n  group_by(exporter) %&gt;%\n  mutate(phi = max(phi, na.rm = T)) %&gt;%\n  ungroup()\n\nWe compute the change in prices for exporters (changes in \\(p_i\\)) and importers (changes in \\(p_j\\)).\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  group_by(exporter) %&gt;%\n  mutate(change_p_i = ((exp(fe_exporter_cfl) / e_r) /\n    (exp(fe_exporter_bln) / e_r))^(1 / (1 - sigma))) %&gt;%\n  ungroup() %&gt;%\n  group_by(importer) %&gt;%\n  mutate(\n    change_p_j = ifelse(importer == exporter, change_p_i, 0),\n    change_p_j = max(change_p_j, na.rm = T)\n  ) %&gt;%\n  ungroup()\n\nNext, we need to compute the counterfactual trade flows.\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  mutate(trade_cfl = tradehat_cfl * change_p_i * change_p_j)\n\nTo conclude the steps from Box #1 we need a while() loop and iterate until convergence is reached. We need to duplicate some columns under new names for the loop operations because we will overwrite them using the iterative steps.\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  mutate(\n    omr_cfl_0 = omr_cfl,\n    imr_cfl_0 = imr_cfl,\n    change_imr_full_0 = 1,\n    change_omr_full_0 = 1,\n    change_p_i_0 = change_p_i,\n    change_p_j_0 = change_p_j,\n    fe_exporter_cfl_0 = fe_exporter_cfl,\n    fe_importer_cfl_0 = fe_importer_cfl,\n    tradehat_0 = tradehat_cfl,\n    e_r_cfl_0 = e_r\n  )\n\nWe run the loop, which cannot be divided into smaller pieces because the step \\(N\\) depends on the step \\(N-1\\). As in the previous application, the idea is for the stopping criteria in this iteration is that the model converges when prices stop changing.\n\ni &lt;- 1\nwhile (sd_dif &gt; 1e-5 | max_dif &gt; 1e-5) {\n  ch2_application1 &lt;- ch2_application1 %&gt;%\n    mutate(trade_1 = tradehat_0 * change_p_i_0 * change_p_j_0 /\n      (change_omr_full_0 * change_imr_full_0))\n\n  # repeat the counterfactual model\n  fit_counterfactual_app1_2 &lt;- fepois(\n    trade_1 ~ 0 | exporter + importer,\n    data = ch2_application1,\n    offset = ~ log(tij_cfl),\n    glm.iter = 500\n  )\n\n  ch2_application1 &lt;- ch2_application1 %&gt;%\n    mutate(\n      fe_exporter_cfl_1 = fixef(fit_counterfactual_app1_2)$exporter[exporter],\n      fe_importer_cfl_1 = fixef(fit_counterfactual_app1_2)$importer[importer]\n    )\n\n  # compute the conditional general equilibrium effects of trade\n  ch2_application1 &lt;- ch2_application1 %&gt;%\n    mutate(tradehat_1 = predict(fit_counterfactual_app1_2, ch2_application1)) %&gt;%\n    group_by(exporter) %&gt;%\n    mutate(y_cfl_1 = sum(tradehat_1, na.rm = T)) %&gt;%\n    ungroup() %&gt;%\n    mutate(e_cfl_1 = ifelse(importer == exporter, phi * y_cfl_1, 0)) %&gt;%\n    group_by(importer) %&gt;%\n    mutate(e_cfl_1 = max(e_cfl_1, na.rm = T)) %&gt;%\n    ungroup() %&gt;%\n    mutate(\n      e_r_cfl_1 = ifelse(importer == paste0(\"0-\", ref_country), e_cfl_1, 0),\n      e_r_cfl_1 = max(e_r_cfl_1, na.rm = T)\n    )\n\n  # compute the change in prices for exporters and importers\n  ch2_application1 &lt;- ch2_application1 %&gt;%\n    mutate(change_p_i_1 = ((exp(fe_exporter_cfl_1) / e_r_cfl_1) /\n      (exp(fe_exporter_cfl_0) / e_r_cfl_0))^(1 / (1 - sigma)))\n\n  # compute the change in prices for exporters and importers\n  ch2_application1 &lt;- ch2_application1 %&gt;%\n    group_by(importer) %&gt;%\n    mutate(\n      change_p_j_1 = ifelse(importer == exporter, change_p_i_1, 0),\n      change_p_j_1 = max(change_p_j_1, na.rm = T)\n    ) %&gt;%\n    ungroup()\n\n  # compute both outward and inward multilateral resistance\n  ch2_application1 &lt;- ch2_application1 %&gt;%\n    mutate(\n      omr_cfl_1 = (y_cfl_1 * e_r_cfl_1) / exp(fe_exporter_cfl_1),\n      imr_cfl_1 = e_cfl_1 / (exp(fe_importer_cfl_1) * e_r_cfl_1)\n    )\n\n  # update the differences\n  max_dif &lt;- abs(max(ch2_application1$change_p_i_0 - change_price_i_old))\n  sd_dif &lt;- sd(ch2_application1$change_p_i_0 - change_price_i_old)\n  change_price_i_old &lt;- ch2_application1$change_p_i_0\n\n  # compute changes in outward and inward multilateral resistance\n  ch2_application1 &lt;- ch2_application1 %&gt;%\n    mutate(\n      change_omr_full_1 = omr_cfl_1 / omr_cfl_0,\n      change_imr_full_1 = imr_cfl_1 / imr_cfl_0,\n      omr_cfl_0 = omr_cfl_1,\n      imr_cfl_0 = imr_cfl_1,\n      change_omr_full_0 = change_omr_full_1,\n      change_imr_full_0 = change_imr_full_1,\n      change_p_i_0 = change_p_i_1,\n      change_p_j_0 = change_p_j_1,\n      fe_exporter_cfl_0 = fe_exporter_cfl_1,\n      fe_importer_cfl_0 = fe_importer_cfl_1,\n      tradehat_0 = tradehat_1,\n      e_r_cfl_0 = e_r_cfl_1\n    ) %&gt;%\n    select(-c(fe_exporter_cfl_1, fe_importer_cfl_1))\n\n  i &lt;- i + 1\n}\n\nWarning: Absence of convergence: Maximum number of iterations reached (500).\nFinal deviance: 0.\n\n\nWarning: Absence of convergence: Maximum number of iterations reached (500).\nFinal deviance: -8.941e-8.\n\n\nWarning: Absence of convergence: Maximum number of iterations reached (500).\nFinal deviance: 2.98e-8.\n\nWarning: Absence of convergence: Maximum number of iterations reached (500).\nFinal deviance: 2.98e-8.\n\n\nIn the previous step, we obtained a warning that we cannot eliminate by increasing GLM interations. The fitted model has truncated deviance for steps eight and twenty-two in the while loop. We tested with 20,000 GLM iterations for each step, resulting in a very similar message:\n\nWarning: Absence of convergence: Maximum number of iterations reached (20000). Final deviance: 3.725e-8. Warning: Absence of convergence: Maximum number of iterations reached (20000). Final deviance: -4.47e-8.\n\nThis is not a problem by itself, and we can disregard this. A very different case would be estimating a model with high collinearity, resulting in coefficients with undefined standard errors and an unreliable result.\nBox #1 from page 108 in Yotov et al. (2016) shows the steps to obtain different endowments, which can be divided into smaller pieces. We start computing the full endowment general equilibrium of factory-gate price (changes in \\(p_i^{full}\\) and \\(p_j^{full}\\)) and the full endowment general equilibrium of output (\\(y^{full}\\)).\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  mutate(\n    change_p_i_full = ((exp(fe_exporter_cfl_0) / e_r_cfl_0) /\n      (exp(fe_exporter_bln) / e_r))^(1 / (1 - sigma)),\n    change_p_j_full = change_p_i_full * (exporter == importer)\n  ) %&gt;%\n  group_by(importer) %&gt;%\n  mutate(change_p_j_full = max(change_p_j_full, na.rm = T)) %&gt;%\n  ungroup() %&gt;%\n  mutate(y_full = change_p_i_full * y)\n\nWe compute the full endowment general equilibrium of aggregate expenditures (\\(e^{full}\\) and \\(e_r^{full}\\)).\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  mutate(e_full = change_p_j_full * e * (exporter == importer)) %&gt;%\n  group_by(importer) %&gt;%\n  mutate(e_full = max(e_full, na.rm = TRUE)) %&gt;%\n  ungroup() %&gt;%\n  mutate(\n    e_full_r = e_full * (importer == ref_country0),\n    e_full_r = max(e_full_r, na.rm = T)\n  )\n\nWith the aggregate expenditure, we proceed to obtain the full endowment general equilibrium of the outward multilateral resistance (\\(OMR^{full}\\)) and inward multilateral resistance (\\(IMR^{full}\\)).\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  mutate(\n    omr_full = y_full * e_r_cfl_0 / exp(fe_exporter_cfl_0),\n    imr_full = e_full / (exp(fe_importer_cfl_0) * e_full_r)\n  )\n\nFinally, we proceed to compute the full endowment general equilibrium of trade (\\(\\xi^{full}\\)).\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  mutate(x_full = (y_full * e_full * tij_cfl) / (imr_full * omr_full)) %&gt;%\n  group_by(exporter) %&gt;%\n  mutate(xi_full = sum(x_full * (importer != exporter), na.rm = T)) %&gt;%\n  ungroup()\n\n\n\n3.1.5 Step IV: Collect, construct, and report indexes of interest\nBox #1 from page 108 in Yotov et al. (2016) consists of constructing the percentage change of the general equilibrium indexes. The steps are direct. We need to compute the change in full endowment general equilibrium factory-gate price on the export side (changes in \\(p_i{full}\\)), the change in conditional and full general equilibrium outward multilateral resistances (changes in \\(OMR^{CFL}\\) and \\(OMR^{full}\\)), and the change in conditional and full general equilibrium international trade (changes in \\(\\xi^{CFL}\\) and \\(\\xi^{full}\\)).\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  mutate(\n    change_price_full = (change_p_i_full - 1) * 100,\n    change_omr_cfl = (omr_cfl^(1 / (1 - sigma)) / omr_bln^(1 / (1 - sigma)) - 1) * 100,\n    change_omr_full = (omr_full^(1 / (1 - sigma)) / omr_bln^(1 / (1 - sigma)) - 1) * 100,\n    change_xi_cfl = (xi_cfl / xi_bln - 1) * 100,\n    change_xi_full = (xi_full / xi_bln - 1) * 100\n  )\n\nWe also need to do something very similar for the importers in order to be able to recreate figure 7 later.\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  mutate(\n    change_imr_full = -(imr_full^(1 / (1 - sigma)) / imr_bln^(1 / (1 - sigma)) - 1) * 100,\n    rgdp = ((y_full / imr_full^(1 / (1 - sigma))) / (y / imr_bln^(1 / (1 - sigma))) - 1) * 100\n  )\n\n\n\n3.1.6 Figures replication\nWith all of the steps above, we are ready to create the plots from page 110. in Yotov et al. (2016). Figure 6 removes the observations where both the importer and the exporter are different, and this can be seen in the original Stata code provided with the book.\nWe need to filter rows and to obtain \\(\\log(y)\\).\n\nch2_application1 &lt;- ch2_application1 %&gt;%\n  filter(exporter == importer) %&gt;%\n  select(\n    exporter, importer, y, change_xi_cfl, change_xi_full, rgdp,\n    change_price_full, change_imr_full\n  ) %&gt;%\n  mutate(log_y = log(y))\n\nIn addition, the original code removes Hong Kong for visualization scale purposes.\n\ndata_figure_6 &lt;- ch2_application1 %&gt;%\n  filter(exporter != \"HKG\") %&gt;%\n  select(x = log_y, change_xi_cfl, change_xi_full) %&gt;%\n  pivot_longer(names_to = \"change\", values_to = \"y\", -x) %&gt;%\n  mutate(\n    change = case_when(\n      change == \"change_xi_cfl\" ~ \"Conditional general equilibrium\",\n      TRUE ~ \"Full endowment general equilibrium\"\n    )\n  )\n\nggplot(data = data_figure_6) +\n  geom_point(aes(x = x, y = y, color = change)) +\n  labs(\n    x = \"Log value of output\",\n    y = \"Percent change of exports\",\n    title = \"Figure 6: Effects of abolishing international borders on exports\",\n    caption = \"Source: Authors' calculations\",\n    color = \"\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\") +\n  scale_color_manual(values = c(\"#b6b8dd\", \"#232958\"))\n\n\n\n\nTo create Figure 7, we proceed in the same way as Figure 6.\n\ndata_figure_7 &lt;- ch2_application1 %&gt;%\n  filter(exporter != \"HKG\") %&gt;%\n  select(x = log_y, change_imr_full, change_price_full, rgdp) %&gt;%\n  pivot_longer(names_to = \"change\", values_to = \"y\", -x) %&gt;%\n  mutate(\n    change = case_when(\n      change == \"change_imr_full\" ~ \"-(inward multilateral resistances)\",\n      change == \"change_price_full\" ~ \"Factory-gate price\",\n      TRUE ~ \"Real GDP\"\n    )\n  )\n\nggplot(data = data_figure_7) +\n  geom_point(aes(x = x, y = y, color = change)) +\n  labs(\n    x = \"Log value of output\",\n    y = \"Percent changes\",\n    title = \"Figure 7: Effects of abolishing international borders on real GDP\",\n    caption = \"Note: The inward multilateral resistances have been reformulated by multiplying their value by minus one.\\nSource: Authors' calculations\",\n    color = \"\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\") +\n  scale_color_manual(values = c(\"#3bade3\", \"#b6b8dd\", \"#232958\"))"
  },
  {
    "objectID": "02-general-equilibrium.html#impact-of-regional-trade-agreements",
    "href": "02-general-equilibrium.html#impact-of-regional-trade-agreements",
    "title": "3  General equilibrium trade policy analysis with structural gravity",
    "section": "3.2 Impact of regional trade agreements",
    "text": "3.2 Impact of regional trade agreements\n\n3.2.1 Initial data\nAs in the previous application, we shall proceed by alternating both data transforming and regressions. To replicate the results from box #1 on page 112 in Yotov et al. (2016), we need to convert “DEU” in both exporter and importer columns to “0-DEU”, as in the previous section.\nWe start by defining some parameters to simplify the code. As the notes in the original Stata code say, the criteria of convergence (\\(\\sigma = 7\\)) was taken from the literature.\n\nref_country &lt;- \"DEU\"\nref_country0 &lt;- paste0(\"0-\", ref_country)\ncountries_rta &lt;- c(\"MEX\", \"USA\", \"CAN\")\nyear_rta &lt;- 1994\nsigma &lt;- 7\nmax_dif &lt;- 1\nsd_dif &lt;- 1\nchange_price_i_old &lt;- 0\n\nIn this case, we shall keep the panel dimension of the dataset to identify the effects of RTAs and comprehensively capture the impact of all time-invariant trade costs with the use of pair fixed effects.\n\nch2_application2 &lt;- agtpa_applications %&gt;%\n  select(exporter, importer, pair_id, year, trade, dist, cntg, lang, clny, rta) %&gt;%\n  filter(year %in% seq(1986, 2006, 4)) %&gt;%\n  mutate(\n    log_dist = log(dist),\n    intl = ifelse(exporter != importer, 1, 0),\n    exporter = ifelse(exporter == ref_country, ref_country0, exporter),\n    importer = ifelse(importer == ref_country, ref_country0, importer)\n  ) %&gt;%\n  # Create Yit\n  group_by(exporter, year) %&gt;%\n  mutate(y = sum(trade, na.rm = T)) %&gt;%\n  # Create Eit\n  group_by(importer, year) %&gt;%\n  mutate(e = sum(trade, na.rm = T)) %&gt;%\n  # Create Er\n  group_by(year) %&gt;%\n  mutate(e_r = max(ifelse(importer == ref_country0, e, NA), na.rm = T)) %&gt;%\n  arrange(importer)\n\nBecause of the panel dimension, we proceed as we did in the previous chapter by creating columns to combine exporter/importer and year alongside a pairing variable for the internal dyads for the fixed effects.\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  mutate(\n    exp_year = paste0(exporter, year),\n    imp_year = paste0(importer, year),\n    pair_id_2 = ifelse(exporter == importer, \"0-domestic\", pair_id)\n  )\n\nIn addition, we need to compute the trade sum to filter the cases where the sum by dyad is zero.\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  group_by(pair_id) %&gt;%\n  mutate(sum_trade = sum(trade, na.rm = T)) %&gt;%\n  ungroup()\n\n\n\n3.2.2 Step 1: Solve the baseline gravity model\n\n3.2.2.1 Stage 1: Obtain the estimates of pair fixed effects and the effects of RTAs\nWith the steps done before, it is straightforward to obtain the PPML regression shown in box #1 from page 112 in Yotov et al. (2016).\n\nfit_baseline_app2 &lt;- fepois(\n  trade ~ rta | exp_year + imp_year + pair_id_2,\n  data = filter(ch2_application2, sum_trade &gt; 0),\n  glm.iter = 500\n)\n\nWe can construct the variables for exporter-time, importer-time, and internal dyads with the estimated fixed effects from the model.\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  mutate(\n    fe_exporter_bln = fixef(fit_baseline_app2)$exp_year[exp_year],\n    fe_importer_bln = fixef(fit_baseline_app2)$imp_year[imp_year],\n    fe_pair_id_2_bln = fixef(fit_baseline_app2)$pair_id_2[pair_id_2]\n  )\n\nNOTE: The fixed-effects are not regular, they cannot be straightforwardly interpreted. The number of references is only approximate.\nNOTE: The fixed-effects are not regular, they cannot be straightforwardly interpreted. The number of references is only approximate.\nNOTE: The fixed-effects are not regular, they cannot be straightforwardly interpreted. The number of references is only approximate.\n\n\n\n\n3.2.2.2 Stage 2: Regress the estimates of pair fixed effects on gravity variables and country fixed effects\nBox #1 from page 113 in Yotov et al. (2016) can be divided into smaller chunks. We start by filtering to keep the observation from 1994, and then we compute the trade costs (\\(\\bar{t}_{ij}\\) and \\(t_{ij}^{BLN}\\)) from the internal dyads fixed effects and the estimated RTA coefficient.\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  mutate(\n    tij_bar = exp(fe_pair_id_2_bln),\n    tij_bln = exp(fe_pair_id_2_bln + fit_baseline_app2$coefficients[\"rta\"] * rta)\n  )\n\nWe need to create a table for the year 1994 and international flows, which we will use to predict the trade costs for the observations with zero trade flows. The reason to create a sub-table, instead of filtering observations in the regression function, is that it eases posterior work to predict the costs.\n\nch2_application2_2 &lt;- ch2_application2 %&gt;%\n  filter(year == year_rta, exporter != importer)\n\nNow, unlike the book, which duplicates \\(\\overline{t_{ij}}\\) by creating \\(t_{ij}\\), we can fit a regression to estimate the costs. This is something that emerges from the small differences between expressing an idea in Stata or R.\n\nfit_costs_app2 &lt;- fepois(\n  tij_bar ~ log_dist + cntg + lang + clny | exporter + importer,\n  data = ch2_application2_2,\n  glm.iter = 500\n)\n\nNOTE: 14 observations removed because of NA values (LHS: 14).\n\n\nWith the regression, we add the fitted values to the sub-table.\n\nch2_application2_2 &lt;- ch2_application2_2 %&gt;%\n  mutate(tij_no_rta = predict(fit_costs_app2, ch2_application2_2)) %&gt;%\n  select(exporter, importer, tij_no_rta)\n\nThe final step is to keep the observations for the year 1994 in the original table and replace the missing costs with the predicted values.\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  filter(year == year_rta) %&gt;%\n  left_join(ch2_application2_2, by = c(\"exporter\", \"importer\")) %&gt;%\n  mutate(\n    tij_bar = ifelse(is.na(tij_bar), tij_no_rta, tij_bar),\n    tij_bln = ifelse(is.na(tij_bln), tij_bar * exp(fit_baseline_app2$coefficients[\"rta\"] * rta), tij_bln)\n  ) %&gt;%\n  select(-tij_no_rta)\n\nBox #2 from page 113 in Yotov et al. (2016) is easier to replicate. The first part of completing Box #2 involves solving the constrained baseline gravity model.\n\nfit_constrained_app2 &lt;- fepois(\n  trade ~ 0 | exporter + importer,\n  data = ch2_application2,\n  offset = ~ log(tij_bln),\n  glm.iter = 500\n)\n\nWith the fitted model, we can add the prediction and the \\(\\xi^{BLN}\\) column.\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  mutate(tradehat_bln = predict(fit_constrained_app2, ch2_application2)) %&gt;%\n  group_by(exporter) %&gt;%\n  mutate(xi_bln = sum(tradehat_bln * (exporter != importer), na.rm = T)) %&gt;%\n  ungroup()\n\nThe book specifies that all other baseline indexes of interest can be obtained by applying the same procedure described in the previous application. Here we will obtain the multilateral resistances terms (\\(OMR^{BLN}\\) and \\(IMR^{BLN}\\)) by adding the fixed effects from the constrained model to the data.\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  mutate(\n    fe_exporter_cns = fixef(fit_constrained_app2)$exporter[exporter],\n    fe_importer_cns = fixef(fit_constrained_app2)$importer[importer]\n  )\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  mutate(\n    omr_bln = y * e_r / exp(fe_exporter_cns),\n    imr_bln = e / (exp(fe_importer_cns) * e_r)\n  )\n\n\n\n\n3.2.3 Step II: Define a counterfactual scenario\nBox #1 from page 114 in Yotov et al. (2016) is direct and consists in replacing the RTA values by zero if the pairs of countries are NAFTA members.\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  mutate(\n    rta_no_nafta = ifelse(exporter %in% countries_rta & importer %in% countries_rta, 0, rta),\n    tij_cfl = tij_bar * exp(fit_baseline_app2$coefficients[\"rta\"] * rta_no_nafta)\n  )\n\n\n\n3.2.4 Step III: Solve the counterfactual model\nThe same procedure from the previous section applies to obtain the conditional general equilibrium effects and then compute the full endowment general equilibrium effects. We start by fitting a counterfactual model.\n\nfit_counterfactual_app2 &lt;- fepois(\n  trade ~ 0 | exporter + importer,\n  data = ch2_application2,\n  offset = ~ log(tij_cfl),\n  glm.iter = 500\n)\n\nWith the fitted model we add the fixed effects.\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  mutate(\n    fe_exporter_cfl = fixef(fit_counterfactual_app2)$exporter[exporter],\n    fe_importer_cfl = fixef(fit_counterfactual_app2)$importer[importer]\n  )\n\nAs we did in stage 2, we compute the multilateral resistance terms.\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  mutate(\n    omr_cfl = y * e_r / exp(fe_exporter_cfl),\n    imr_cfl = e / (exp(fe_importer_cfl) * e_r)\n  )\n\nUp to this point, we are ready to compute the conditional general equilibrium effects of trade.\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  mutate(tradehat_cfl = predict(fit_counterfactual_app2, ch2_application2)) %&gt;%\n  group_by(exporter) %&gt;%\n  mutate(xi_cfl = sum(tradehat_cfl * (exporter != importer), na.rm = T)) %&gt;%\n  ungroup()\n\nNow we are going to compute the full endowment general equilibrium effects. We start by repeating the steps to obtain changes in \\(t_{ij}\\) \\(\\phi\\) from the last section.\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  mutate(\n    change_tij = tij_cfl / tij_bln,\n    phi = ifelse(importer == exporter, e / y, 0)\n  ) %&gt;%\n  group_by(exporter) %&gt;%\n  mutate(phi = max(phi, na.rm = T)) %&gt;%\n  ungroup()\n\nNow we compute changes in \\(p_i\\), \\(p_j\\) and \\(trade^{CFL}\\), which is just a repetition of the previous steps with some adaptation.\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  group_by(exporter) %&gt;%\n  mutate(change_p_i = ((exp(fe_exporter_cfl) / e_r) / (exp(fe_exporter_cns) / e_r))^(1 / (1 - sigma))) %&gt;%\n  ungroup() %&gt;%\n  group_by(importer) %&gt;%\n  mutate(\n    change_p_j = ifelse(importer == exporter, change_p_i, 0),\n    change_p_j = max(change_p_j, na.rm = T)\n  ) %&gt;%\n  ungroup()\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  mutate(trade_cfl = tradehat_cfl * change_p_i * change_p_j)\n\nThen we need a while() loop, but before, we need to duplicate some columns under new names for the loop operations.\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  mutate(\n    omr_cfl_0 = omr_cfl,\n    imr_cfl_0 = imr_cfl,\n    change_imr_full_0 = 1,\n    change_omr_full_0 = 1,\n    change_p_i_0 = change_p_i,\n    change_p_j_0 = change_p_j,\n    fe_exporter_cfl_0 = fe_exporter_cfl,\n    fe_importer_cfl_0 = fe_importer_cfl,\n    tradehat_0 = tradehat_cfl,\n    e_r_cfl_0 = e_r\n  )\n\nFurthermore, now we run the loop, where the step \\(N\\) depends on the step \\(N-1\\) as in the previous section.\n\ni2 &lt;- 1\nwhile (sd_dif &gt; 1e-3 | max_dif &gt; 1e-3) {\n  ch2_application2 &lt;- ch2_application2 %&gt;%\n    mutate(trade_1 = tradehat_0 * change_p_i_0 * change_p_j_0 / (change_omr_full_0 * change_imr_full_0))\n\n  # repeat the counterfactual model\n  fit_counterfactual_app2_2 &lt;- fepois(\n    trade_1 ~ 0 | exporter + importer,\n    data = ch2_application2,\n    offset = ~ log(tij_cfl),\n    glm.iter = 500\n  )\n\n  ch2_application2 &lt;- ch2_application2 %&gt;%\n    mutate(\n      fe_exporter_cfl = fixef(fit_counterfactual_app2_2)$exporter[exporter],\n      fe_importer_cfl = fixef(fit_counterfactual_app2_2)$importer[importer]\n    )\n\n  # compute the conditional general equilibrium effects of trade\n  ch2_application2 &lt;- ch2_application2 %&gt;%\n    mutate(tradehat_1 = predict(fit_counterfactual_app2_2, ch2_application2)) %&gt;%\n    group_by(exporter) %&gt;%\n    mutate(y_cfl_1 = sum(tradehat_1, na.rm = T)) %&gt;%\n    ungroup() %&gt;%\n    mutate(e_cfl_1 = ifelse(importer == exporter, phi * y_cfl_1, 0)) %&gt;%\n    group_by(importer) %&gt;%\n    mutate(e_cfl_1 = max(e_cfl_1, na.rm = T)) %&gt;%\n    ungroup() %&gt;%\n    mutate(\n      e_r_cfl_1 = ifelse(importer == ref_country0, e_cfl_1, 0),\n      e_r_cfl_1 = max(e_r_cfl_1, na.rm = T)\n    )\n\n  # compute the change in prices for exporters and importers\n  ch2_application2 &lt;- ch2_application2 %&gt;%\n    mutate(change_p_i_1 = ((exp(fe_exporter_cfl) / e_r_cfl_1) /\n      (exp(fe_exporter_cfl_0) / e_r_cfl_0))^(1 / (1 - sigma)))\n\n  # compute the change in prices for exporters and importers\n  ch2_application2 &lt;- ch2_application2 %&gt;%\n    group_by(importer) %&gt;%\n    mutate(\n      change_p_j_1 = ifelse(importer == exporter, change_p_i_1, 0),\n      change_p_j_1 = max(change_p_j_1, na.rm = T)\n    ) %&gt;%\n    ungroup()\n\n  # compute both outward and inward multilateral resistance\n  ch2_application2 &lt;- ch2_application2 %&gt;%\n    mutate(\n      omr_cfl_1 = (y_cfl_1 * e_r_cfl_1) / exp(fe_exporter_cfl),\n      imr_cfl_1 = e_cfl_1 / (exp(fe_importer_cfl) * e_r_cfl_1)\n    )\n\n  # update the differences\n  max_dif &lt;- abs(max(ch2_application2$change_p_i_0 - change_price_i_old, na.rm = T))\n  sd_dif &lt;- sd(ch2_application2$change_p_i_0 - change_price_i_old)\n  change_price_i_old &lt;- ch2_application2$change_p_i_0\n\n  # compute changes in outward and inward multilateral resistance\n  ch2_application2 &lt;- ch2_application2 %&gt;%\n    mutate(\n      change_omr_full_1 = omr_cfl_1 / omr_cfl_0,\n      change_imr_full_1 = imr_cfl_1 / imr_cfl_0,\n      omr_cfl_0 = omr_cfl_1,\n      imr_cfl_0 = imr_cfl_1,\n      change_omr_full_0 = change_omr_full_1,\n      change_imr_full_0 = change_imr_full_1,\n      change_p_i_0 = change_p_i_1,\n      change_p_j_0 = change_p_j_1,\n      fe_exporter_cfl_0 = fe_exporter_cfl,\n      fe_importer_cfl_0 = fe_importer_cfl,\n      tradehat_0 = tradehat_1,\n      e_r_cfl_0 = e_r_cfl_1\n    ) %&gt;%\n    select(-fe_exporter_cfl, -fe_importer_cfl)\n\n  i2 &lt;- i2 + 1\n}\n\nThe last loop allows us to obtain changes in \\(p_i^{full}\\), \\(p_j^{full}\\) and \\(y^{full}\\).\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  mutate(\n    change_p_i_full = ((exp(fe_exporter_cfl_0) / e_r_cfl_0) /\n      (exp(fe_exporter_cns) / e_r))^(1 / (1 - sigma)),\n    change_p_j_full = change_p_i_full * (exporter == importer)\n  ) %&gt;%\n  group_by(importer) %&gt;%\n  mutate(change_p_j_full = max(change_p_j_full, na.rm = T)) %&gt;%\n  ungroup() %&gt;%\n  mutate(y_full = change_p_i_full * y)\n\nNow we compute $e^{full} and \\(e_r^{full}\\).\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  mutate(e_full = change_p_j_full * e * (exporter == importer)) %&gt;%\n  group_by(importer) %&gt;%\n  mutate(e_full = max(e_full, na.rm = T)) %&gt;%\n  ungroup() %&gt;%\n  mutate(\n    e_full_r = e_full * (importer == ref_country0),\n    e_full_r = max(e_full_r, na.rm = T)\n  )\n\nWe also need omr_full and imr_full. This part of the code needs attention because the IMR full term is computed in a different way compared to the previous section. Please see the script RTAsEffects.do.\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  mutate(\n    omr_full = y_full * e_r_cfl_0 / exp(fe_exporter_cfl_0),\n    imr_full = e_cfl_1 / (exp(fe_importer_cfl_0) * e_r_cfl_0)\n  )\n\nTo complete this step, we compute \\(\\xi^{full}\\).\n\nch2_application2 &lt;- ch2_application2 %&gt;%\n  mutate(x_full = (y_full * e_full * tij_cfl) / (imr_full * omr_full)) %&gt;%\n  group_by(exporter) %&gt;%\n  mutate(xi_full = sum(x_full * (importer != exporter), na.rm = T)) %&gt;%\n  ungroup()\n\n\n\n3.2.5 Step IV: Collect, construct, and report indexes of interest\nThis step aims to reproduce the table from page 116 in Yotov et al. (2016).\nTo ease the task of creating the table from the book, we divide between exporter and importer indexes.\n\nexporter_indexes &lt;- ch2_application2 %&gt;%\n  select(\n    exporter, starts_with(\"omr_\"), change_p_i_full,\n    starts_with(\"xi_\"), y, y_full\n  ) %&gt;%\n  distinct() %&gt;%\n  mutate(exporter = ifelse(exporter == ref_country0, ref_country, exporter)) %&gt;%\n  arrange(exporter) %&gt;%\n  mutate(\n    change_p_i_full = (1 - change_p_i_full) * 100,\n    change_omr_cfl = ((omr_bln / omr_cfl)^(1 / (1 - sigma)) - 1) * 100,\n    change_omr_full = ((omr_bln / omr_full)^(1 / (1 - sigma)) - 1) * 100,\n    change_xi_cfl = (xi_bln / xi_cfl - 1) * 100,\n    change_xi_full = (xi_bln / xi_full - 1) * 100\n  ) %&gt;%\n  select(exporter, starts_with(\"change\"), starts_with(\"y\"))\n\nimporter_indexes &lt;- ch2_application2 %&gt;%\n  select(importer, imr_bln, imr_cfl, imr_full) %&gt;%\n  distinct() %&gt;%\n  mutate(importer = ifelse(importer == ref_country0, ref_country, importer)) %&gt;%\n  arrange(importer) %&gt;%\n  mutate(\n    change_imr_cfl = ((imr_bln / imr_cfl)^(1 / (1 - sigma)) - 1) * 100,\n    change_imr_full = ((imr_bln / imr_full)^(1 / (1 - sigma)) - 1) * 100\n  )\n\nFinally, we can replicate the table that we wanted to."
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Solutions Manual for An Advanced Guide to Trade Policy Analysis in R (3rd Edition)",
    "section": "1.9 References",
    "text": "1.9 References\n\n\n\n\nBryan, Jennifer, Jim Hester, and STAT 545 TAs. 2020. “Happy Git with r.” https://happygitwithr.com/.\n\n\nWickham, Hadley, and Garrett Grolemund. 2016. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. \" O’Reilly Media, Inc.\".\n\n\nYotov, Yoto V, Roberta Piermartini, José-Antonio Monteiro, and Mario Larch. 2016. An Advanced Guide to Trade Policy Analysis: The Structural Gravity Model. World Trade Organization Geneva."
  },
  {
    "objectID": "01-traditional-gravity.html#references",
    "href": "01-traditional-gravity.html#references",
    "title": "2  Partial equilibrium trade policy analysis with structural gravity",
    "section": "2.4 References",
    "text": "2.4 References\n\n\n\n\nSilva, JMC Santos, and Silvana Tenreyro. 2006. “The Log of Gravity.” The Review of Economics and Statistics 88 (4): 641–58.\n\n\nWickham, Hadley, and Garrett Grolemund. 2016. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. \" O’Reilly Media, Inc.\".\n\n\nYotov, Yoto V, Roberta Piermartini, José-Antonio Monteiro, and Mario Larch. 2016. An Advanced Guide to Trade Policy Analysis: The Structural Gravity Model. World Trade Organization Geneva.\n\n\nZumel, Nina. 2014. “Trimming the Fat from Glm() Models in r.” https://win-vector.com/2014/05/30/trimming-the-fat-from-glm-models-in-r/."
  },
  {
    "objectID": "02-general-equilibrium.html#references",
    "href": "02-general-equilibrium.html#references",
    "title": "3  General equilibrium trade policy analysis with structural gravity",
    "section": "3.3 References",
    "text": "3.3 References\n\n\n\n\nYotov, Yoto V, Roberta Piermartini, José-Antonio Monteiro, and Mario Larch. 2016. An Advanced Guide to Trade Policy Analysis: The Structural Gravity Model. World Trade Organization Geneva."
  }
]
[
["index.html", "Solutions Manual for An Advanced Guide to Trade Policy Analysis Chapter 1 Introduction 1.1 Welcome 1.2 Obtaining the datasets and functions 1.3 Getting the most out of this material", " Solutions Manual for An Advanced Guide to Trade Policy Analysis Mauricio “Pachá” Vargas Sepúlveda 2020-10-10 Chapter 1 Introduction 1.1 Welcome Welcome to our online solutions manual for for An Advanced Guide to Trade Policy Analysis (Yotov et al. 2016). This material is intended to provide a comprehensive explanation to reproduce the book’s results in R. We don’t attempt to give a thorough discussion of the theory behind gravity models, the references cited through the chapters shall fill those details. The manual is written for two audiences: People who know R and are interested in learning about gravity models. People with no R knowledge who know gravity models theory. We only assume that readers are familiar with linear regression, and that they shall read Yotov et al. (2016) and Wickham and Grolemund (2016) alongside this material. What we did here was to replicate all the results from the book, made with Stata, in R as a way to contribute to Reproducible Research. R is free and available on almost every operating system. It is a wonderful tool for all statistical analysis. 1.2 Obtaining the datasets and functions yotover is an R package and what you are reading here is the package documentation. In specific, it acts as a metapackage which calls other packages to use several functions that augment R capabilities. You can get all the functions and datasets if you run these lines from your R console: if (!require(&quot;remotes&quot;)) install.packages(&quot;remotes&quot;) remotes::install_github(&quot;pachamaltese/yotover&quot;) 1.3 Getting the most out of this material Clone this repo to obtain the editable R Markdown files: git clone https://github.com/pachamaltese/yotover.git Please read Bryan, Hester, and STAT 545 TAs (2020) if you have questions about git or GitHub. References "],
["partial-equilibrium-trade-policy-analysis-with-structural-gravity.html", "Chapter 2 Partial equilibrium trade policy analysis with structural gravity 2.1 Traditional Gravity Estimates 2.2 The “distance puzzle” resolved 2.3 Regional trade agreements effects", " Chapter 2 Partial equilibrium trade policy analysis with structural gravity 2.1 Traditional Gravity Estimates 2.1.1 Preparing the data If you haven’t used R before, or to be more precise, you have only fitted a few regressions without much practice on transforming and cleaning data before, check chapters 5 and 18 from Wickham and Grolemund (2016). Please see the note from page 42 in Yotov et al. (2016). It’s a really important note, which tells us that we need to: Filter observations for a range of years (1986, 1990, 1994, 1998, 2002 and 2006) Transform some variables to logarithm scale (trade and dist) and create new variables from those in the original dataset Remove cases where both the exporter and the importer are the same Drop observations where the trade flow is zero Provided that the datasets use 3 GB on disk, we opted to use a local SQL database (DuckDB) instead of spreadsheets or even native R files. If you are not familiar with SQL, do not worry because we provide the function yotov_data(), so that yotov_data(\"ch1_application1\") goes to the database and returns the data for this exercise. Step 1 is straightforward: library(yotover) ## ── Attaching packages ───────────────────────────────────────────────────────── yotover 0.0.0.9000 ── ## ✓ dplyr 1.0.2 ✓ lmtest 0.9.38 ## ✓ tidyr 1.1.2 ✓ broom 0.7.0 ## ✓ multiwayvcov 1.2.3 ✓ msm 1.6.8 ## ✓ sandwich 2.5.1 ✓ duckdb 0.2.1 ## ── ✓ Local Yotov database is OK. ──────────────────────────────────────────────────────────────────── ch1_application1_2 &lt;- yotov_data(&quot;ch1_application1&quot;) %&gt;% filter(year %in% seq(1986, 2006, 4)) For step 2, this can be divided in parts, starting with the log transformation of trade and dist: ch1_application1_2 &lt;- ch1_application1_2 %&gt;% mutate( log_trade = log(trade), log_dist = log(dist) ) Continuing step 2, we can now create the variables \\(Y_{i,t}\\) and \\(E_{i,t}\\) that appear on the OLS model equation: ch1_application1_2 &lt;- ch1_application1_2 %&gt;% # Create Yit group_by(exporter, year) %&gt;% mutate( y = sum(trade), log_y = log(y) ) %&gt;% # Create Eit group_by(importer, year) %&gt;% mutate( e = sum(trade), log_e = log(e) ) The OLS model with remoteness index needs both exporter and importer index, which can be created by grouping variables: ch1_application1_2 &lt;- ch1_application1_2 %&gt;% # Replicate total_e group_by(exporter, year) %&gt;% mutate(total_e = sum(e)) %&gt;% group_by(year) %&gt;% mutate(total_e = max(total_e)) %&gt;% # Replicate rem_exp group_by(exporter, year) %&gt;% mutate( remoteness_exp = sum(dist * total_e / e), log_remoteness_exp = log(remoteness_exp) ) %&gt;% # Replicate total_y group_by(importer, year) %&gt;% mutate(total_y = sum(y)) %&gt;% group_by(year) %&gt;% mutate(total_y = max(total_y)) %&gt;% # Replicate rem_imp group_by(importer, year) %&gt;% mutate( remoteness_imp = sum(dist / (y / total_y)), log_remoteness_imp = log(remoteness_imp) ) To create the variables for the OLS with Fixed Effects Model, we followed box #1 in page 44 from Yotov et al. (2016): ch1_application1_2 &lt;- ch1_application1_2 %&gt;% # This merges the columns exporter/importer with year mutate( exp_year = paste0(exporter, year), imp_year = paste0(importer, year) ) This concludes step 2. Now we need to perform step 3: ch1_application1_2 &lt;- ch1_application1_2 %&gt;% filter(exporter != importer) Step 4 is used in some cases and we will be explicit about it. 2.1.2 OLS estimation ignoring multilateral resistance terms The general equation for this model is: \\[ \\begin{align} \\log X_{ij,t} =&amp; \\:\\beta_0 + \\beta_1 DIST_{i,j} + \\beta_2 CNTG_{i,j} + \\beta_3 LANG_{i,j} + \\beta_4 CLNY_{i,j} + \\beta_5 \\log Y_{i,t} +\\\\ \\text{ }&amp; \\:\\beta_6 \\log E_{j,t} + \\varepsilon_{ij,t} \\end{align} \\] See page 41 in Yotov et al. (2016) for a full detail of each variable. The model for this case is straightforward, and in this case we need to apply step 4 from thje previous section to drop cases where the trade is zero: fit_ols &lt;- lm( log_trade ~ log_dist + cntg + lang + clny + log_y + log_e, data = ch1_application1_2 %&gt;% filter(trade &gt; 0) ) summary(fit_ols) ## ## Call: ## lm(formula = log_trade ~ log_dist + cntg + lang + clny + log_y + ## log_e, data = ch1_application1_2 %&gt;% filter(trade &gt; 0)) ## ## Residuals: ## Min 1Q Median 3Q Max ## -14.5421 -0.8281 0.1578 1.0476 7.6585 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -11.283080 0.151732 -74.36 &lt; 2e-16 *** ## log_dist -1.001607 0.014159 -70.74 &lt; 2e-16 *** ## cntg 0.573805 0.074427 7.71 1.31e-14 *** ## lang 0.801548 0.033748 23.75 &lt; 2e-16 *** ## clny 0.734853 0.070387 10.44 &lt; 2e-16 *** ## log_y 1.190236 0.005402 220.32 &lt; 2e-16 *** ## log_e 0.907588 0.005577 162.73 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.743 on 25682 degrees of freedom ## Multiple R-squared: 0.7585, Adjusted R-squared: 0.7585 ## F-statistic: 1.345e+04 on 6 and 25682 DF, p-value: &lt; 2.2e-16 Now the model is almost ready! Now we only need to stick to the methodology from Yotov et al. (2016) and cluster the standard errors by country pair (see the note in page 42, it is extremely important). This is not straightforward and requieres additional work. The yotover package provides a nice function to do this and more. Please read the documentation of the package and look the yotov_model_summary() function, it summarises the model in the exact way as reported in the book by providing: Clustered standard errors Number of observations \\(R^2\\) (if applicable) Presence (or absence) of exporter and exporter time fixed effects RESET test p-value This is returned as a list to keep it simple. Finally, here is the model as reported in the book: yotov_model_summary( formula = &quot;log_trade ~ log_dist + cntg + lang + clny + log_y + log_e&quot;, method = &quot;lm&quot;, data = filter(ch1_application1_2, trade &gt; 0) ) ## $tidy_coefficients ## # A tibble: 7 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) -11.3 0.296 -38.1 1.17e-309 ## 2 log_dist -1.00 0.0273 -36.6 1.85e-286 ## 3 cntg 0.574 0.185 3.11 1.90e- 3 ## 4 lang 0.802 0.0821 9.76 1.78e- 22 ## 5 clny 0.735 0.144 5.10 3.49e- 7 ## 6 log_y 1.19 0.00946 126. 0. ## 7 log_e 0.908 0.00991 91.6 0. ## ## $nobs ## [1] 25689 ## ## $rsquared ## [1] 0.7585251 ## ## $etfe ## [1] FALSE ## ## $itfe ## [1] FALSE ## ## $reset_pval ## [1] 4.346285e-15 2.1.3 OLS estimation controlling for multilateral resistance terms with remote indexes The remoteness model adds variables to the OLS model. The general equation for this model is: \\[ \\begin{align} \\log X_{ij,t} =&amp; \\:\\beta_0 + \\beta_1 DIST_{i,j} + \\beta_2 CNTG_{i,j} + \\beta_3 LANG_{i,j} + \\beta_4 CLNY_{i,j} + \\beta_5 \\log Y_{i,t} +\\\\ \\text{ }&amp; \\beta_6 \\log E_{j,t} + \\beta_7 \\log(REM\\_EXP_i,t) + \\beta_8 \\log(REM\\_IMP_i,t) + \\varepsilon_{ij,t} \\end{align} \\] Where \\[ \\log(REM\\_EXP_{i,t}) = \\log \\left( \\sum_j \\frac{DIST_{i,j}}{E_{j,t} / Y_t} \\right)\\\\ \\log(REM\\_IMP_{i,t}) = \\log \\left( \\sum_i \\frac{DIST_{i,j}}{E_{i,t} / Y_t} \\right) \\] See page 43 in Yotov et al. (2016) for a full detail of each variable. We can start from the dataset for the OLS model, and add the additional variables to it. Our ch1_approach follows box #1 in page 43 from Yotov et al. (2016): Now fitting the regression is straightforward, it’s just about adding more regressors to what we did in the last section: fit_ols_remoteness &lt;- lm( log_trade ~ log_dist + cntg + lang + clny + log_y + log_e + log_remoteness_exp + log_remoteness_imp, data = filter(ch1_application1_2, trade &gt; 0) ) As we did with OLS, we can create a list with a summary for the model: yotov_model_summary( formula = &quot;log_trade ~ log_dist + cntg + lang + clny + log_y + log_e + log_remoteness_exp + log_remoteness_imp&quot;, method = &quot;lm&quot;, data = filter(ch1_application1_2, trade &gt; 0) ) ## $tidy_coefficients ## # A tibble: 9 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) -35.2 1.99 -17.7 6.28e- 70 ## 2 log_dist -1.18 0.0313 -37.9 9.17e-306 ## 3 cntg 0.247 0.177 1.39 1.63e- 1 ## 4 lang 0.739 0.0784 9.43 4.48e- 21 ## 5 clny 0.842 0.150 5.61 2.08e- 8 ## 6 log_y 1.16 0.00948 123. 0. ## 7 log_e 0.903 0.00991 91.1 0. ## 8 log_remoteness_exp 0.972 0.0682 14.3 6.66e- 46 ## 9 log_remoteness_imp 0.274 0.0598 4.58 4.71e- 6 ## ## $nobs ## [1] 25689 ## ## $rsquared ## [1] 0.765028 ## ## $etfe ## [1] FALSE ## ## $itfe ## [1] FALSE ## ## $reset_pval ## [1] 7.672904e-14 2.1.4 OLS estimation controlling for multilateral resistance terms with fixed effects The general equation for this model is: \\[ \\begin{align} \\log X_{ij,t} =&amp; \\:\\pi_{i,t} + \\chi_{i,t} + \\beta_1 \\log(DIST)_{i,j} + \\beta_2 CNTG_{i,j} + \\beta_3 LANG_{i,j} +\\\\ \\text{ }&amp; \\:\\beta_4 CLNY_{i,j} + \\varepsilon_{ij,t} \\end{align} \\] Where the added terms, with respect to the OLS model, are \\(\\pi_{i,t}\\) and \\(\\chi_{i,t}\\) that account for exporter-time and importer-time fixed effects respectively. See page 44 in Yotov et al. (2016) for a full detail of each variable. We can start from the dataset for the OLS model, and add the additional variables to it. In this case we take the OLS dataset and combine both exporter and importer variables with the year in order to create the fixed effects variables. The difference between this model and the two previous is that we specify the cluster specification (pair_id) inside felm() for the standard error, while in the two previous cases the yotov_model_summary() function performs additional computation by calling multiwayvcov and lmtest packages. With the data from above, the model specification is straightforward: fit_fe &lt;- lm( log_trade ~ log_dist + cntg + lang + clny + exp_year + imp_year, data = filter(ch1_application1_2, trade &gt; 0) ) Here we won’t print the output of summary(fit_fe) because the model estimates 831 coefficients in this case because of time exporter/importer fixed effects. Now we can easily generate a list as we did with the previous models: yotov_model_summary( formula = &quot;log_trade ~ log_dist + cntg + lang + clny + exp_year + imp_year&quot;, method = &quot;lm&quot;, data = filter(ch1_application1_2, trade &gt; 0) ) ## $tidy_coefficients ## # A tibble: 5 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 13.1 0.508 25.7 4.44e-144 ## 2 log_dist -1.22 0.0382 -31.8 3.77e-218 ## 3 cntg 0.223 0.203 1.10 2.71e- 1 ## 4 lang 0.661 0.0821 8.05 8.41e- 16 ## 5 clny 0.670 0.149 4.49 7.24e- 6 ## ## $nobs ## [1] 25689 ## ## $rsquared ## [1] 0.8432398 ## ## $etfe ## [1] TRUE ## ## $itfe ## [1] TRUE ## ## $reset_pval ## [1] 2.473022e-231 2.1.5 PPML estimation controlling for multilateral resistance terms with fixed effects The general equation for this model is: \\[ \\begin{align} X_{ij,t} =&amp; \\:\\exp\\left[\\pi_{i,t} + \\chi_{i,t} + \\beta_1 \\log(DIST)_{i,j} + \\beta_2 CNTG_{i,j} +\\right.\\\\ \\text{ }&amp; \\:\\left.\\beta_3 LANG_{i,j} + \\beta_4 CLNY_{i,j}\\right] \\times \\varepsilon_{ij,t} \\end{align} \\] The reason to compute this model even in spite of speed is that PPML is the only estimator that is perfectly consistent with the theoretical gravity model. By estimating with PPML the fixed effects correspond exactly to the corresponding theoretical terms. The data for this model is exactly the same as for the fixed effects model. One option in R is to use the glm() function and a quasi-poisson family to avoid overdispersion problems: fit_ppml &lt;- glm(trade ~ log_dist + cntg + lang + clny + exp_year + imp_year, family = quasipoisson(link = &quot;log&quot;), data = ch1_application1_2 ) The summary won’t be printed for the same reason as for the OLS Fixed Effects model. If you decide to print the summary yourself, you’ll notice that it doesn’t report \\(R^2\\), as it needs to be computed afterwards as a function of the correlation between the observed and predicted values. Please see Silva and Tenreyro (2006) for the details as well as for the RESET test for PPML (GLM) models. Software such as Stata reports an incorrect \\(R^2\\) for PPML model, it actually reports a pseudo-\\(R^2\\). To construct a proper \\(R^2\\), yotov_model_summary() takes the correlation between actual and predicted trade flows. Finally we can obtain a detailed list as in the previous examples: yotov_model_summary( formula = &quot;trade ~ log_dist + cntg + lang + clny + exp_year + imp_year&quot;, method = &quot;glm&quot;, data = ch1_application1_2 ) ## $tidy_coefficients ## # A tibble: 5 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 10.4 0.459 22.7 5.51e-114 ## 2 log_dist -0.841 0.0321 -26.2 5.66e-151 ## 3 cntg 0.437 0.0844 5.18 2.19e- 7 ## 4 lang 0.247 0.0777 3.19 1.44e- 3 ## 5 clny -0.222 0.118 -1.89 5.93e- 2 ## ## $nobs ## [1] 28152 ## ## $rsquared ## [1] 0.5859927 ## ## $etfe ## [1] TRUE ## ## $itfe ## [1] TRUE ## ## $reset_pval ## [1] 0.6415408 Please notice that the previous summary intentionally doesn’t show time exporter/importer fixed effects. 2.2 The “distance puzzle” resolved 2.2.1 Preparing the data Please see the note from page 47 in Yotov et al. (2016). We need to proceed with similar steps as in the previous section. Unlike the previous section, we will create different tables for OLS, PPML and its variations, because the solution for the “distance puzzle” implies different transformations and filters for each case. The distance puzzle proposes this gravity specification: \\[ \\begin{align} X_{ij,t} =&amp; \\:\\exp\\left[\\pi_{i,t} + \\chi_{i,t} + \\beta_1 \\log(DIST)_{i,j} + \\beta_2 CNTG_{i,j} + \\beta_3 LANG_{i,j}\\right]\\times\\\\ \\text{ }&amp; \\:\\exp\\left[\\beta_4 CLNY_{i,j} + \\beta_5 \\log(DIST\\_INTRA_{i,i})\\right] \\times \\varepsilon_{ij,t} \\end{align} \\] The difference with respect to the last section is that now we need to separate the log_dist variable into multiple columns that account for discrete time effects. This is expressed into the \\(\\beta_T\\) terms of the equation. Perhaps the easiest option to do this is to transform year into a text column and then use the spread() function. For the OLS model we need to remove cases where the exporter is the same as the importer and cases where trade is zero. For the PPML models we need to mark rows where the exporter and the importer are the same, and we need to create the smctry column, which is also required to transform the log_dist_* variables as shown in box #1 in page 48 from Yotov et al. (2016): In order to avoid creating two datasets that are very similar, we shall create one dataset to cover both OLS and PPML: ch1_application2_2 &lt;- yotov_data(&quot;ch1_application2&quot;) %&gt;% # this filter covers both OLS and PPML filter(year %in% seq(1986, 2006, 4)) %&gt;% mutate( # variables for both OLS and PPML exp_year = paste0(exporter, year), imp_year = paste0(importer, year), year = paste0(&quot;log_dist_&quot;, year), log_trade = log(trade), log_dist = log(dist), # PPML specific variables smctry = ifelse(importer != exporter, 0, 1), log_dist_intra = log_dist * smctry, intra_pair = ifelse(exporter == importer, exporter, &quot;inter&quot;) ) %&gt;% spread(year, log_dist, fill = 0) %&gt;% mutate(across(log_dist_1986:log_dist_2006, ~ .x * (1 - smctry))) Here the across() function is a shortcut to avoid writing something like: ch1_application2_2 %&gt;% mutate( log_dist_1986 = log_dist_1986 * (1 - smctry), log_dist_1990 = log_dist_1990 * (1 - smctry), ... REPEAT log_dist_T many_times .... log_dist_2006 = log_dist_2006 * (1 - smctry) ) Also notice that the OLS model shall require filtering when we specify the model, because we skipped filtering the cases where trade is equal to zero and both the importer and the exporter are the same. 2.2.2 OLS solution for the “distance puzzle” The gravity specification, which includes \\(\\pi_{i,t} + \\chi_{i,t}\\), means that we need to do something very similar to what we did in the last section. With the data from above, the model specification is straightforward: yotov_model_summary2( formula = &quot;log_trade ~ 0 + log_dist_1986 + log_dist_1990 + log_dist_1994 + log_dist_1998 + log_dist_2002 + log_dist_2006 + cntg + lang + clny + exp_year + imp_year&quot;, method = &quot;lm&quot;, data = filter(ch1_application2_2, importer != exporter, trade &gt; 0) ) ## $tidy_coefficients ## # A tibble: 9 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 log_dist_1986 -1.17 0.0436 -26.8 9.33e-156 ## 2 log_dist_1990 -1.16 0.0423 -27.3 1.10e-161 ## 3 log_dist_1994 -1.21 0.0457 -26.5 1.07e-152 ## 4 log_dist_1998 -1.25 0.0428 -29.2 4.14e-184 ## 5 log_dist_2002 -1.24 0.0441 -28.1 1.34e-171 ## 6 log_dist_2006 -1.26 0.0437 -28.9 4.02e-180 ## 7 cntg 0.223 0.203 1.10 2.71e- 1 ## 8 lang 0.661 0.0821 8.06 8.20e- 16 ## 9 clny 0.670 0.149 4.49 7.25e- 6 ## ## $nobs ## [1] 25689 ## ## $pct_chg_log_dist ## [1] 7.950156 ## ## $pcld_std_err ## [1] 3.75886 ## ## $pcld_std_err_pval ## [1] 0.03442616 ## ## $intr ## [1] FALSE ## ## $csfe ## [1] FALSE Notice that, unlike the previous section, we used the notation y ~ 0 + .... The zero means not to include a constant. 2.2.3 PPML solution for the “distance puzzle” This model is very similar to the one specified in the PPML section from the last section. We can fit the model in a direct way: yotov_model_summary2( formula = &quot;trade ~ 0 + log_dist_1986 + log_dist_1990 + log_dist_1994 + log_dist_1998 + log_dist_2002 + log_dist_2006 + cntg + lang + clny + exp_year + imp_year&quot;, method = &quot;glm&quot;, data = filter(ch1_application2_2, importer != exporter) ) ## $tidy_coefficients ## # A tibble: 9 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 log_dist_1986 -0.859 0.0376 -22.9 1.44e-115 ## 2 log_dist_1990 -0.834 0.0382 -21.8 1.97e-105 ## 3 log_dist_1994 -0.835 0.0356 -23.4 1.75e-121 ## 4 log_dist_1998 -0.847 0.0359 -23.6 4.50e-123 ## 5 log_dist_2002 -0.848 0.0321 -26.4 1.08e-153 ## 6 log_dist_2006 -0.836 0.0317 -26.3 5.88e-153 ## 7 cntg 0.437 0.0844 5.18 2.23e- 7 ## 8 lang 0.248 0.0777 3.19 1.45e- 3 ## 9 clny -0.222 0.118 -1.88 5.97e- 2 ## ## $nobs ## [1] 28152 ## ## $pct_chg_log_dist ## [1] -2.750345 ## ## $pcld_std_err ## [1] 3.049186 ## ## $pcld_std_err_pval ## [1] 0.3670606 ## ## $intr ## [1] FALSE ## ## $csfe ## [1] FALSE 2.2.4 Internal distance solution for the “distance puzzle” This model just requires us to add the log_dist_intra variable to the PPML model and not to filter the rows where the exporter and the importer are the same: yotov_model_summary2( formula = &quot;trade ~ 0 + log_dist_1986 + log_dist_1990 + log_dist_1994 + log_dist_1998 + log_dist_2002 + log_dist_2006 + cntg + lang + clny + exp_year + imp_year + log_dist_intra&quot;, method = &quot;glm&quot;, data = ch1_application2_2 ) ## $tidy_coefficients ## # A tibble: 10 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 log_dist_1986 -0.980 0.0731 -13.4 5.66e-41 ## 2 log_dist_1990 -0.940 0.0742 -12.7 8.96e-37 ## 3 log_dist_1994 -0.915 0.0731 -12.5 6.06e-36 ## 4 log_dist_1998 -0.887 0.0721 -12.3 9.16e-35 ## 5 log_dist_2002 -0.884 0.0717 -12.3 6.12e-35 ## 6 log_dist_2006 -0.872 0.0724 -12.1 1.85e-33 ## 7 cntg 0.371 0.142 2.62 8.76e- 3 ## 8 lang 0.337 0.171 1.98 4.81e- 2 ## 9 clny 0.0192 0.159 0.121 9.04e- 1 ## 10 log_dist_intra -0.488 0.102 -4.78 1.76e- 6 ## ## $nobs ## [1] 28566 ## ## $pct_chg_log_dist ## [1] -10.96483 ## ## $pcld_std_err ## [1] 1.073772 ## ## $pcld_std_err_pval ## [1] 8.805433e-25 ## ## $intr ## [1] TRUE ## ## $csfe ## [1] FALSE 2.2.5 Internal distance and home bias solution for the “distance puzzle” This model just requires us to add the smctry variable to the internal distance model and repeat the rest of the steps from the last section: yotov_model_summary2( formula = &quot;trade ~ 0 + log_dist_1986 + log_dist_1990 + log_dist_1994 + log_dist_1998 + log_dist_2002 + log_dist_2006 + cntg + lang + clny + exp_year + imp_year + log_dist_intra + smctry&quot;, method = &quot;glm&quot;, data = ch1_application2_2 ) ## $tidy_coefficients ## # A tibble: 11 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 log_dist_1986 -0.857 0.0636 -13.5 2.12e-41 ## 2 log_dist_1990 -0.819 0.0642 -12.7 3.15e-37 ## 3 log_dist_1994 -0.796 0.0644 -12.4 4.84e-35 ## 4 log_dist_1998 -0.770 0.0639 -12.0 2.17e-33 ## 5 log_dist_2002 -0.767 0.0636 -12.1 1.69e-33 ## 6 log_dist_2006 -0.754 0.0631 -12.0 6.42e-33 ## 7 cntg 0.574 0.157 3.65 2.67e- 4 ## 8 lang 0.352 0.139 2.53 1.13e- 2 ## 9 clny 0.0269 0.127 0.212 8.32e- 1 ## 10 log_dist_intra -0.602 0.111 -5.44 5.41e- 8 ## 11 smctry 1.69 0.582 2.90 3.72e- 3 ## ## $nobs ## [1] 28566 ## ## $pct_chg_log_dist ## [1] -11.96934 ## ## $pcld_std_err ## [1] 1.190509 ## ## $pcld_std_err_pval ## [1] 4.412162e-24 ## ## $intr ## [1] TRUE ## ## $csfe ## [1] FALSE 2.2.6 Fixed effects solution for the “distance puzzle” This model just requires us to remove the variables log_dist_intra and smctry from the last model and include the intra_pair variable to account for the intra-national fixed effects: yotov_model_summary2( formula = &quot;trade ~ 0 + log_dist_1986 + log_dist_1990 + log_dist_1994 + log_dist_1998 + log_dist_2002 + log_dist_2006 + cntg + lang + clny + exp_year + imp_year + intra_pair&quot;, method = &quot;glm&quot;, data = ch1_application2_2 ) ## $tidy_coefficients ## # A tibble: 9 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 log_dist_1986 -0.910 0.0328 -27.7 2.26e-169 ## 2 log_dist_1990 -0.879 0.0326 -27.0 4.97e-160 ## 3 log_dist_1994 -0.860 0.0324 -26.6 1.32e-155 ## 4 log_dist_1998 -0.833 0.0322 -25.9 8.22e-148 ## 5 log_dist_2002 -0.829 0.0325 -25.5 2.41e-143 ## 6 log_dist_2006 -0.811 0.0325 -24.9 4.67e-137 ## 7 cntg 0.442 0.0830 5.33 9.87e- 8 ## 8 lang 0.241 0.0772 3.11 1.84e- 3 ## 9 clny -0.220 0.118 -1.86 6.27e- 2 ## ## $nobs ## [1] 28566 ## ## $pct_chg_log_dist ## [1] -10.93109 ## ## $pcld_std_err ## [1] 0.7811861 ## ## $pcld_std_err_pval ## [1] 8.607967e-45 ## ## $intr ## [1] TRUE ## ## $csfe ## [1] TRUE 2.3 Regional trade agreements effects 2.3.1 Preparing the data This model specification includes gravity covariates, including both importer and exporter time fixed effects: \\[ \\begin{align} X_{ij,t} =&amp; \\:\\exp\\left[\\pi_{i,t} + \\chi_{i,t} + \\beta_1 \\log(DIST)_{i,j} + \\beta_2 CNTG_{i,j} + \\beta_3 LANG_{i,j} +\\right.\\\\ \\text{ }&amp; \\:\\left.\\beta_4 CLNY_{i,j} + \\beta_5 RTA_{ij,t}\\right] \\times \\varepsilon_{ij,t} \\end{align} \\] We need to create additional variables, in comparison to the previous examples, to include fixed effects that account for the observations where the exporter and the importer are the same. These variables are intl_brdr, pair_id_2 and the columns of the form intl_border_Y where Y corresponds to the year. The direct way of obtaining the desired variables is quite similar to what we did in the previous sections: ch1_application3_2 &lt;- yotov_data(&quot;ch1_application3&quot;) %&gt;% filter(year %in% seq(1986, 2006, 4)) %&gt;% mutate( exp_year = paste0(exporter, year), imp_year = paste0(importer, year), year = paste0(&quot;intl_border_&quot;, year), log_trade = log(trade), log_dist = log(dist), intl_brdr = ifelse(exporter == importer, pair_id, &quot;inter&quot;), intl_brdr_2 = ifelse(exporter == importer, 0, 1), pair_id_2 = ifelse(exporter == importer, &quot;intra&quot;, pair_id) ) %&gt;% spread(year, intl_brdr_2, fill = 0) In addition, we need to create the variable sum_trade to filter the cases where the sum by pair_id is zero: ch1_application3_2 &lt;- ch1_application3_2 %&gt;% group_by(pair_id) %&gt;% mutate(sum_trade = sum(trade)) %&gt;% ungroup() 2.3.2 OLS standard RTA estimates with international trade only The gravity specification, which includes \\(\\pi_{i,t} + \\chi_{i,t}\\), means that we need to do something very similar to what we did in the last section. With the data from above, the model specification is straightforward: yotov_model_summary3( formula = &quot;log_trade ~ 0 + log_dist + cntg + lang + clny + rta + exp_year + imp_year&quot;, method = &quot;lm&quot;, data = filter(ch1_application3_2, trade &gt; 0, importer != exporter) ) ## $tidy_coefficients ## # A tibble: 5 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 log_dist -1.22 0.0390 -31.2 1.92e-209 ## 2 cntg 0.223 0.203 1.10 2.72e- 1 ## 3 lang 0.661 0.0821 8.05 8.94e- 16 ## 4 clny 0.670 0.149 4.49 7.24e- 6 ## 5 rta -0.00439 0.0540 -0.0813 9.35e- 1 ## ## $nobs ## [1] 25689 ## ## $total_rta_effect ## [1] -0.004389628 ## ## $trta_std_err ## [1] 0.05398407 ## ## $trta_std_err_pval ## [1] 0.9351927 ## ## $intr ## [1] FALSE 2.3.3 PPML standard RTA estimates with international trade only The model specification is very similar to OLS and we only need to change the function lm(): yotov_model_summary3( formula = &quot;trade ~ 0 + log_dist + cntg + lang + clny + rta + exp_year + imp_year&quot;, method = &quot;glm&quot;, data = filter(ch1_application3_2, importer != exporter) ) ## $tidy_coefficients ## # A tibble: 5 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 log_dist -0.822 0.0314 -26.1 1.80e-150 ## 2 cntg 0.416 0.0840 4.94 7.63e- 7 ## 3 lang 0.250 0.0778 3.21 1.32e- 3 ## 4 clny -0.205 0.116 -1.77 7.66e- 2 ## 5 rta 0.191 0.0668 2.86 4.29e- 3 ## ## $nobs ## [1] 28152 ## ## $total_rta_effect ## [1] 0.1907176 ## ## $trta_std_err ## [1] 0.06678383 ## ## $trta_std_err_pval ## [1] 0.004293603 ## ## $intr ## [1] FALSE 2.3.4 Addressing potential domestic trade diversion The model specification is quite the same as PPML and we only need to add the variable intl_brdr but using the full dataset instead of removing rows where the importer and the exporter are the same: yotov_model_summary3( formula = &quot;trade ~ 0 + log_dist + cntg + lang + clny + rta + exp_year + imp_year + intl_brdr&quot;, method = &quot;glm&quot;, data = ch1_application3_2 ) ## $tidy_coefficients ## # A tibble: 5 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 log_dist -0.800 0.0307 -26.0 2.45e-149 ## 2 cntg 0.393 0.0801 4.91 9.27e- 7 ## 3 lang 0.244 0.0783 3.11 1.86e- 3 ## 4 clny -0.182 0.115 -1.58 1.14e- 1 ## 5 rta 0.409 0.0699 5.84 5.16e- 9 ## ## $nobs ## [1] 28566 ## ## $total_rta_effect ## [1] 0.4085219 ## ## $trta_std_err ## [1] 0.06993087 ## ## $trta_std_err_pval ## [1] 5.164081e-09 ## ## $intr ## [1] TRUE 2.3.5 Addressing potential endogeneity of RTAs The model specification consists in including the rta variable and the fixed effects exp_year, imp_year and pair_id_2 to account for domestic trade: yotov_model_summary3( formula = &quot;trade ~ 0 + rta + exp_year + imp_year + pair_id_2&quot;, method = &quot;glm&quot;, data = filter(ch1_application3_2, sum_trade &gt; 0) ) ## $tidy_coefficients ## # A tibble: 1 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 rta 0.557 0.0143 39.0 1.20e-322 ## ## $nobs ## [1] 28482 ## ## $total_rta_effect ## [1] 0.5571853 ## ## $trta_std_err ## [1] 0.1084293 ## ## $trta_std_err_pval ## [1] 2.766506e-07 ## ## $intr ## [1] TRUE 2.3.6 Testing for potential “reverse causality” between trade and RTAs We need to modify the previous model in order to include the variable rta_lead4 and to consider where sum_trade is greater than zero: yotov_model_summary3( formula = &quot;trade ~ 0 + rta + rta_lead4 + exp_year + imp_year + pair_id_2&quot;, method = &quot;glm&quot;, data = filter(ch1_application3_2, sum_trade &gt; 0) ) ## $tidy_coefficients ## # A tibble: 2 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 rta 0.520 0.0911 5.71 0.0000000113 ## 2 rta_lead4 0.0774 0.0977 0.793 0.428 ## ## $nobs ## [1] 28482 ## ## $total_rta_effect ## [1] 0.5974906 ## ## $trta_std_err ## [1] 0.1463918 ## ## $trta_std_err_pval ## [1] 4.475609e-05 ## ## $intr ## [1] TRUE 2.3.7 Addressing potential non-linear and phasing-in effects of RTAs Instead of future-lagged rta variable, as in the previous model, we modify the previous model and include the rta_lagN past-lagged variables instead: yotov_model_summary3( formula = &quot;trade ~ 0 + rta + rta_lag4 + rta_lag8 + rta_lag12 + exp_year + imp_year + pair_id_2&quot;, method = &quot;glm&quot;, data = filter(ch1_application3_2, sum_trade &gt; 0) ) ## $tidy_coefficients ## # A tibble: 4 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 rta 0.291 0.0946 3.08 0.00206 ## 2 rta_lag4 0.414 0.0713 5.80 0.00000000671 ## 3 rta_lag8 0.169 0.0458 3.69 0.000226 ## 4 rta_lag12 0.119 0.0319 3.73 0.000192 ## ## $nobs ## [1] 28482 ## ## $total_rta_effect ## [1] 0.9926189 ## ## $trta_std_err ## [1] 0.0999689 ## ## $trta_std_err_pval ## [1] 1.552499e-23 ## ## $intr ## [1] TRUE 2.3.8 Addressing globalization effects Just as an addition to the previous model, we include the variables intl_border_T variables in addition to rta_lagN: yotov_model_summary3( formula = &quot;trade ~ 0 + rta + rta_lag4 + rta_lag8 + rta_lag12 + intl_border_1986 + intl_border_1990 + intl_border_1994 + intl_border_1998 + intl_border_2002 + exp_year + imp_year + pair_id_2&quot;, method = &quot;glm&quot;, data = filter(ch1_application3_2, sum_trade &gt; 0) ) ## $tidy_coefficients ## # A tibble: 9 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 rta 0.116 0.0920 1.26 2.08e- 1 ## 2 rta_lag4 0.288 0.0654 4.40 1.09e- 5 ## 3 rta_lag8 0.0693 0.0511 1.36 1.75e- 1 ## 4 rta_lag12 0.00236 0.0309 0.0763 9.39e- 1 ## 5 intl_border_1986 -0.706 0.0507 -13.9 4.88e-44 ## 6 intl_border_1990 -0.480 0.0456 -10.5 5.50e-26 ## 7 intl_border_1994 -0.367 0.0355 -10.3 5.29e-25 ## 8 intl_border_1998 -0.158 0.0247 -6.41 1.50e-10 ## 9 intl_border_2002 -0.141 0.0179 -7.87 3.62e-15 ## ## $nobs ## [1] 28482 ## ## $total_rta_effect ## [1] 0.4750185 ## ## $trta_std_err ## [1] 0.1161348 ## ## $trta_std_err_pval ## [1] 4.309359e-05 ## ## $intr ## [1] TRUE References "],
["general-equilibrium-trade-policy-analysis-with-structural-gravity.html", "Chapter 3 General equilibrium trade policy analysis with structural gravity 3.1 Trade without borders", " Chapter 3 General equilibrium trade policy analysis with structural gravity 3.1 Trade without borders 3.1.1 Initial data Unlike the previous chapter, we shall proceed by alternating both data transforming and regressions. In the previous chapter it was possible to first process the datasets and then fit the regressions, but here we need the regressions’ output in order to create new variables. In any case we will follow quite similar steps to the last chapter. To do what is shown in box #1 from page 104 in Yotov et al. (2016), we need to convert “DEU” in both exporter and importer columns to “0-DEU”. We could have used “AAA”, the book uses “ZZZ” but in R “ZZZ” won’t be treated as the reference factor. It is important to mention that box #1 doesn’t show a previous step that is mentioned in page 103, which is to filter and keep observations for the year 2006 only. ch2_application1 &lt;- yotov_data(&quot;ch2_application1&quot;) %&gt;% filter(year == 2006) %&gt;% mutate( log_dist = log(dist), intl = ifelse(exporter != importer, 1, 0), exporter = ifelse(exporter == &quot;DEU&quot;, &quot;0-DEU&quot;, exporter), importer = ifelse(importer == &quot;DEU&quot;, &quot;0-DEU&quot;, importer) ) %&gt;% # Create Yit group_by(exporter, year) %&gt;% mutate(y = sum(trade)) %&gt;% # Create Eit group_by(importer, year) %&gt;% mutate(e = sum(trade)) %&gt;% # Create Er ungroup() %&gt;% mutate(e_r = max(ifelse(importer == &quot;0-DEU&quot;, e, NA), na.rm = T)) 3.1.2 Step I: Solve the baseline model We start by fitting the next model: \\[ \\begin{align} X_{ij,t} =&amp; \\:\\exp\\left[\\pi_{i,t} + \\chi_{i,t} + \\beta_1 \\log(DIST)_{i,j} + \\beta_2 CNTG_{i,j} + \\beta_3 INTL_{i,j}\\right] \\times \\varepsilon_{ij,t} \\end{align} \\] With the data from above, the model specification is straightforward: fit_baseline &lt;- glm( trade ~ 0 + log_dist + cntg + intl + exporter + importer, family = quasipoisson(link = &quot;log&quot;), data = ch2_application1 ) For now, we will concentrate on the fitted values and shall ignore the clustered standard errors in the next paragraphs, but still we can show the robust estimation by using the yotov_robust_glm() function: yotov_robust_glm(fit_baseline$formula, ch2_application1) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## log_dist -0.791288 0.062781 -12.6040 &lt; 2.2e-16 *** ## cntg 0.673646 0.139803 4.8185 1.446e-06 *** ## intl -2.474450 0.149266 -16.5775 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 With the estimated model, we can proceed as in box #1 from page 105 in Yotov et al. (2016) in order to construct the variables for export and import fixed effects: ch2_application1 &lt;- ch2_application1 %&gt;% left_join(yotov_fixed_effects(fit_baseline)) ## Joining, by = c(&quot;exporter&quot;, &quot;importer&quot;) Still following box #1, we need to compute the variables of bilateral trade costs and multilateral resistances: ch2_application1 &lt;- ch2_application1 %&gt;% mutate( tij_bln = exp(fit_baseline$coefficients[&quot;log_dist&quot;] * log_dist + fit_baseline$coefficients[&quot;cntg&quot;] * cntg + fit_baseline$coefficients[&quot;intl&quot;] * intl), # outward multilateral resistance (omr) omr_bln = y * (e_r / exp(fe_exporter)), # inward multilateral resistance (imr) imr_bln = e / (exp(fe_importer) * e_r) ) To complete this stage of the estimation, we need to create a column with the estimated international trade for given output and expenditures. We start by adding a column, tradehat_bln, with the regression output, and then we group by exporter and summarise to obtain the required column xi_bln: ch2_application1 &lt;- ch2_application1 %&gt;% mutate(tradehat_bln = fit_baseline$fitted.values) %&gt;% group_by(exporter) %&gt;% mutate(xi_bln = sum(tradehat_bln * (exporter != importer))) %&gt;% ungroup() 3.1.3 Step II: Define a counterfactual scenario Box #2 from page 105 in Yotov et al. (2016) proposes two alternatives to define counterfactual scenario of removing international borders. The first alternative is to eliminate the border variable and then generate the logged trade costs used in the constraint: ch2_application1 &lt;- ch2_application1 %&gt;% mutate( tij_cfl = exp(fit_baseline$coefficients[&quot;log_dist&quot;] * log_dist + fit_baseline$coefficients[&quot;cntg&quot;] * cntg), log_tij_cfl = log(tij_cfl) ) The second alternative is to define a new counterfactual border variable: ch2_application1 &lt;- ch2_application1 %&gt;% mutate( intl_cfl = 0, tij_bln = exp(fit_baseline$coefficients[&quot;log_dist&quot;] * log_dist + fit_baseline$coefficients[&quot;cntg&quot;] * cntg + fit_baseline$coefficients[&quot;intl&quot;] * intl_cfl), log_tij_cfl = log(tij_cfl) ) 3.1.4 Step III: Solve the counterfactual model We need to fit a model similar to the model from step I, the constrained gravity model, where \\(\\pi_{j,t}\\) and \\(\\chi_{j,t}\\) are altered: \\[ \\begin{align} X_{ij,t} =&amp; \\:\\exp\\left[\\pi_{i,t}^{CFL} + \\chi_{i,t}^{CFL} + \\beta_1 \\log(DIST)_{i,j} + \\beta_2 CNTG_{i,j} + \\beta_3 INTL_{i,j}\\right] \\times \\varepsilon_{ij,t} \\end{align} \\] Box #1 from page 106 in Yotov et al. (2016) estimates the constrained gravity model with the PPML estimator by using an offset argument, and this is straightforward in R: fit_counterfactual &lt;- glm( trade ~ 0 + exporter + importer + offset(log_tij_cfl), family = quasipoisson(link = &quot;log&quot;), data = ch2_application1 ) Unlike step I, to construct the variables for export and import fixed effects, we’ll obtain the variables fe_exporter.x and fe_exporter.y because we already added an fe_exporter column to the dataset after obtaining the baseline model. dplyr is wise enough to rename the two fe_exporter columns (the same applies to the imports) but we need to specify that we want to join by exporter and importer instead of all columns with shared names. In any case, it is better to rename those columns and provide informative names: ch2_application1 &lt;- ch2_application1 %&gt;% left_join( yotov_fixed_effects(fit_counterfactual), by = c(&quot;exporter&quot;, &quot;importer&quot;) ) %&gt;% rename( fe_exporter_bln = fe_exporter.x, fe_exporter_cfl = fe_exporter.y, fe_importer_bln = fe_importer.x, fe_importer_cfl = fe_importer.y ) Now we go for Box #2 from page 106 in Yotov et al. (2016) where the variables of bilateral trade costs and multilateral resistances are obtained: ch2_application1 &lt;- ch2_application1 %&gt;% mutate( # outward multilateral resistance (omr) omr_cfl = y * (e_r / exp(fe_exporter_cfl)), # inward multilateral resistance (imr) imr_cfl = e / (exp(fe_importer_cfl) * e_r) ) Box #2 also shows how to compute the conditional general equilibrium effects of trade. This is very similar to what we did in step I: ch2_application1 &lt;- ch2_application1 %&gt;% mutate(tradehat_cfl = fit_counterfactual$fitted.values) %&gt;% group_by(exporter) %&gt;% mutate(xi_cfl = sum(tradehat_cfl * (exporter != importer))) %&gt;% ungroup() Box #1 from page 107 in Yotov et al. (2016) can be considerably simplified with R code. To construct the iterative procedure to converge to full endowment general equilibrium effects, we start by creating the required columns and parameters, so we will deviate from the original approach. We start computing change in bilateral trade costs (change_tij) and trade deficit or surplus (phi): # set the criteria of convergence # taken from the literature (see the Stata code) sigma &lt;- 7 ch2_application1 &lt;- ch2_application1 %&gt;% mutate( change_tij = tij_cfl / tij_bln, phi = ifelse(importer == exporter, e / y, 0) ) %&gt;% group_by(exporter) %&gt;% mutate(phi = max(phi)) %&gt;% ungroup() Now we compute change in prices for exporters (change_p_i) and importers (change_p_j): ch2_application1 &lt;- ch2_application1 %&gt;% group_by(exporter) %&gt;% mutate(change_p_i = ((exp(fe_exporter_cfl) / e_r) / (exp(fe_exporter_bln) / e_r))^(1 /(1 - sigma))) %&gt;% ungroup() %&gt;% group_by(importer) %&gt;% mutate( change_p_j = ifelse(importer == exporter, change_p_i, 0), change_p_j = max(change_p_j) ) %&gt;% ungroup() Next, we need to compute the counterfactual trade flows (trade_cfl): ch2_application1 &lt;- ch2_application1 %&gt;% mutate(trade_cfl = tradehat_cfl * change_p_i * change_p_j) To conclude the steps from Box #1 we need a while() loop and iterate until a convergence is reached. We need to duplicate some columns under new names for the loop operations, because we will overwrite them when using the iterative steps: ch2_application1 &lt;- ch2_application1 %&gt;% mutate( omr_cfl_0 = omr_cfl, imr_cfl_0 = imr_cfl, change_imr_full_0 = 1, change_omr_full_0 = 1, change_p_i_0 = change_p_i, change_p_j_0 = change_p_j, fe_exporter_cfl_0 = fe_exporter_cfl, fe_importer_cfl_0 = fe_importer_cfl, tradehat_0 = tradehat_cfl, e_r_cfl_0 = e_r ) And now we run the loop, which cannot be divided into smaller pieces because the step \\(N\\) depends on the step \\(N-1\\): # set parameters max_dif &lt;- 1 sd_dif &lt;- 1 change_price_i_old &lt;- 0 while(sd_dif &gt; 1e-5 | max_dif &gt; 1e-5) { ch2_application1 &lt;- ch2_application1 %&gt;% mutate(trade_1 = tradehat_0 * change_p_i_0 * change_p_j_0 / (change_omr_full_0 * change_imr_full_0)) # repeat the counterfactual model fit_counterfactual_2 &lt;- glm( trade_1 ~ 0 + exporter + importer + offset(log_tij_cfl), family = quasipoisson(link = &quot;log&quot;), data = ch2_application1 ) ch2_application1 &lt;- ch2_application1 %&gt;% left_join( yotov_fixed_effects(fit_counterfactual_2), by = c(&quot;exporter&quot;, &quot;importer&quot;) ) # compute the conditional general equilibrium effects of trade ch2_application1 &lt;- ch2_application1 %&gt;% mutate(tradehat_1 = fit_counterfactual_2$fitted.values) %&gt;% group_by(exporter) %&gt;% mutate(y_cfl_1 = sum(tradehat_1)) %&gt;% ungroup() %&gt;% mutate(e_cfl_1 = ifelse(importer == exporter, phi * y_cfl_1, 0)) %&gt;% group_by(importer) %&gt;% mutate(e_cfl_1 = max(e_cfl_1)) %&gt;% ungroup() %&gt;% mutate( e_r_cfl_1 = ifelse(importer == &quot;0-DEU&quot;, e_cfl_1, 0), e_r_cfl_1 = max(e_r_cfl_1) ) # compute the change in prices for exporters and importers ch2_application1 &lt;- ch2_application1 %&gt;% mutate(change_p_i_1 = ((exp(fe_exporter) / e_r_cfl_1) / (exp(fe_exporter_cfl_0) / e_r_cfl_0))^(1 / (1 - sigma))) # compute the change in prices for exporters and importers ch2_application1 &lt;- ch2_application1 %&gt;% group_by(importer) %&gt;% mutate( change_p_j_1 = ifelse(importer == exporter, change_p_i_1, 0), change_p_j_1 = max(change_p_j_1) ) %&gt;% ungroup() # compute both outward and inward multilateral resistance ch2_application1 &lt;- ch2_application1 %&gt;% mutate( omr_cfl_1 = (y_cfl_1 * e_r_cfl_1) / exp(fe_exporter), imr_cfl_1 = e_cfl_1 / (exp(fe_importer) * e_r_cfl_1) ) # update the differences max_dif &lt;- abs(max(ch2_application1$change_p_i_0 - change_price_i_old)) sd_dif &lt;- sd(ch2_application1$change_p_i_0 - change_price_i_old) change_price_i_old &lt;- ch2_application1$change_p_i_0 # compute changes in outward and inward multilateral resistance ch2_application1 &lt;- ch2_application1 %&gt;% mutate( change_omr_full_1 = omr_cfl_1 / omr_cfl_0, change_imr_full_1 = imr_cfl_1 / imr_cfl_0, omr_cfl_0 = omr_cfl_1, imr_cfl_0 = imr_cfl_1, change_omr_full_0 = change_omr_full_1, change_imr_full_0 = change_imr_full_1, change_p_i_0 = change_p_i_1, change_p_j_0 = change_p_j_1, fe_exp_cfl_0 = fe_exporter, fe_imp_cfl_0 = fe_importer, tradehat_0 = tradehat_1, e_r_cfl_0 = e_r_cfl_1 ) %&gt;% select(-fe_exporter, -fe_importer) } Box #1 from page 108 in Yotov et al. (2016) shows the steps to obtain different endowments, which can be divided into smaller pieces. We start computing the full endowment general equilibrium of factory-gate price (change_p_i_full and change_p_j_full) and the full endowment general equilibrium of output (y_full): ch2_application1 &lt;- ch2_application1 %&gt;% mutate( change_p_i_full = ((exp(fe_exporter_cfl_0) / e_r_cfl_0) / (exp(fe_exporter_bln) / e_r))^(1 / (1 - sigma)), change_p_j_full = change_p_i_full * (exporter == importer) ) %&gt;% group_by(importer) %&gt;% mutate(change_p_j_full = max(change_p_j_full)) %&gt;% ungroup() %&gt;% mutate(y_full = change_p_i_full * y) Now we compute the full endowment general equilibrium of aggregate expenditures (e_full and e_full_r): ch2_application1 &lt;- ch2_application1 %&gt;% mutate(e_full = change_p_j_full * e * (exporter == importer)) %&gt;% group_by(importer) %&gt;% mutate(e_full = max(e_full, na.rm = TRUE)) %&gt;% ungroup() %&gt;% mutate( e_full_r = e_full * (importer == &quot;0-DEU&quot;), e_full_r = max(e_full_r) ) With the aggregate expenditure we proceed to obtain the full endowment general equilibrium of the outward multilateral resistance (omr_full) and inward multilateral resistance (imr_full): ch2_application1 &lt;- ch2_application1 %&gt;% mutate( omr_full = y_full * e_r_cfl_0 / exp(fe_exporter_cfl_0), imr_full = e_full / (exp(fe_importer_cfl_0) * e_full_r) ) Finally we proceed to compute the full endowment general equilibrium of trade (xi_full): ch2_application1 &lt;- ch2_application1 %&gt;% mutate(x_full = (y_full * e_full * tij_cfl) / (imr_full * omr_full)) %&gt;% group_by(exporter) %&gt;% mutate(xi_full = sum(x_full * (importer != exporter))) %&gt;% ungroup() 3.1.5 Step IV: Collect, construct, and report indexes of interest Box #1 from page 108 in Yotov et al. (2016) consists in to construct the percentage change of the general equilibrium indexes. The steps are direct, we need to compute the change in full endowment general equilibrium factory-gate price on export side (change_price_full), the change in conditional and full general equilibrium outward multilateral resistances (change_omr_*), and the change in conditional and full general equilibrium international trade (change_xi_*): ch2_application1 &lt;- ch2_application1 %&gt;% mutate( change_price_full = (change_p_i_full - 1) * 100, change_omr_cfl = (omr_cfl^(1 / (1 - sigma)) / omr_bln^(1 / (1 - sigma)) - 1) * 100, change_omr_full = (omr_full^(1 / (1 - sigma)) / omr_bln^(1 / (1 - sigma)) - 1) * 100, change_xi_cfl = (xi_cfl / xi_bln - 1) * 100, change_xi_full = (xi_full / xi_bln - 1) * 100 ) In addition to this, we need to something very similar for importers, in order to be able to recreate figure 7 later: ch2_application1 &lt;- ch2_application1 %&gt;% mutate( change_imr_full = -(imr_full^(1 / (1 - sigma)) / imr_bln^(1 / (1 - sigma)) - 1) * 100, rgdp = ((y_full / imr_full^(1 / (1 - sigma))) / (y / imr_bln^(1 / (1 - sigma))) - 1) * 100 ) 3.1.6 Figures replication With all of the steps above, we are ready to create the plots from page 110. in Yotov et al. (2016). Figure 6 removes the observations where both the importer and the exporter are different, this can be seen in the original Stata code provided with the book. We need to filter rows and to obtain log(y): ch2_application1 &lt;- ch2_application1 %&gt;% filter(exporter == importer) %&gt;% select(exporter, importer, y, change_xi_cfl, change_xi_full, rgdp, change_price_full, change_imr_full) %&gt;% mutate(log_y = log(y)) In addition, the original code removes Hong Kong for visualization scale purposes: ggplot(data = ch2_application1 %&gt;% filter(exporter != &quot;HKG&quot;)) + geom_point(aes(x = log_y, y = change_xi_cfl, color = &quot;1&quot;)) + geom_point(aes(x = log_y, y = change_xi_full, color = &quot;2&quot;)) + labs( x = &quot;Log value of output&quot;, y = &quot;Percent change of exports&quot;, title = &quot;Figure 6: Effects of abolishing international borders on exports&quot;, caption = &quot;Source: Authors&#39; calculations&quot;, color = &quot;&quot; ) + theme_minimal() + theme(legend.position = &quot;bottom&quot;) + scale_color_manual( labels = c( &quot;Conditional general equilibrium&quot;, &quot;Full endowment general equilibrium&quot; ), values = c(&quot;#b6b8dd&quot;,&quot;#232958&quot;) ) To create figure 7, we proceed in the same way as we did with figure 6: ggplot(data = ch2_application1 %&gt;% filter(exporter != &quot;HKG&quot;)) + geom_point(aes(x = log_y, y = change_imr_full, color = &quot;1&quot;)) + geom_point(aes(x = log_y, y = change_price_full, color = &quot;2&quot;)) + geom_point(aes(x = log_y, y = rgdp, color = &quot;3&quot;)) + labs( x = &quot;Log value of output&quot;, y = &quot;Percent changes&quot;, title = &quot;Figure 7: Effects of abolishing international borders on real GDP&quot;, caption = &quot;Note: The inward multilateral resistances have been reformulated by multiplying their value by minus one.\\nSource: Authors&#39; calculations&quot;, color = &quot;&quot; ) + theme_minimal() + theme(legend.position = &quot;bottom&quot;) + scale_color_manual( labels = c( &quot;-(inward multilateral resistances)&quot;, &quot;Factory-gate price&quot;, &quot;Real GDP&quot; ), values = c(&quot;#3bade3&quot;, &quot;#b6b8dd&quot;, &quot;#232958&quot;) ) References "],
["data.html", "Chapter 4 Appendix: Importing the original datasets 4.1 Software 4.2 Downloading the original datasets 4.3 Converting the original datasets", " Chapter 4 Appendix: Importing the original datasets 4.1 Software I followed the standards and conventions from the Tidyverse, and I converted all the original datasets in Stata with this software: R version 3.6.3 (2020-02-29) Platform: x86_64-pc-linux-gnu (64-bit) locale: LC_CTYPE=en_US.UTF-8, LC_NUMERIC=C, LC_TIME=es_CL.UTF-8, LC_COLLATE=en_US.UTF-8, LC_MONETARY=es_CL.UTF-8, LC_MESSAGES=en_US.UTF-8, LC_PAPER=es_CL.UTF-8, LC_NAME=C, LC_ADDRESS=C, LC_TELEPHONE=C, LC_MEASUREMENT=es_CL.UTF-8 and LC_IDENTIFICATION=C attached base packages: stats, graphics, grDevices, utils, datasets, methods and base other attached packages: ggplot2(v.3.3.2), duckdb(v.0.2.1), DBI(v.1.1.0), msm(v.1.6.8), broom(v.0.7.0), lmtest(v.0.9-38), zoo(v.1.8-8), sandwich(v.2.5-1), multiwayvcov(v.1.2.3), tidyr(v.1.1.2), dplyr(v.1.0.2) and yotover(v.0.0.0.9000) loaded via a namespace (and not attached): tidyselect(v.1.1.0), xfun(v.0.17), pander(v.0.6.3), purrr(v.0.3.4), splines(v.3.6.3), lattice(v.0.20-41), colorspace(v.1.4-1), vctrs(v.0.3.4), generics(v.0.0.2), expm(v.0.999-5), htmltools(v.0.5.0), yaml(v.2.2.1), survival(v.3.1-12), rlang(v.0.4.7), R.oo(v.1.24.0), pillar(v.1.4.6), glue(v.1.4.2), withr(v.2.3.0), R.utils(v.2.10.1), rappdirs(v.0.3.1), lifecycle(v.0.2.0), stringr(v.1.4.0), munsell(v.0.5.0), gtable(v.0.3.0), R.methodsS3(v.1.8.1), mvtnorm(v.1.1-1), codetools(v.0.2-16), evaluate(v.0.14), labeling(v.0.3), knitr(v.1.30), parallel(v.3.6.3), fansi(v.0.4.1), Rcpp(v.1.0.5), backports(v.1.1.10), scales(v.1.1.1), farver(v.2.0.3), digest(v.0.6.25), stringi(v.1.5.3), bookdown(v.0.20), grid(v.3.6.3), cli(v.2.0.2), tools(v.3.6.3), magrittr(v.1.5), tibble(v.3.0.3), crayon(v.1.3.4), pkgconfig(v.2.0.3), ellipsis(v.0.3.1), Matrix(v.1.2-18), assertthat(v.0.2.1), rmarkdown(v.2.3), httr(v.1.4.2), rstudioapi(v.0.11), R6(v.2.4.1), boot(v.1.3-25) and compiler(v.3.6.3) 4.2 Downloading the original datasets appfiles_url &lt;- &quot;https://vi.unctad.org/tpa/web/zips/vol2/Advanced%20Guide%20to%20TPA.zip&quot; appfiles_zip &lt;- &quot;00-application-files.zip&quot; appfiles_dir &lt;- &quot;00-application-files&quot; if (!file.exists(appfiles_zip)) { download.file(appfiles_url, appfiles_zip) } if (!dir.exists(appfiles_dir)) { unzip(appfiles_zip) file.rename(&quot;Advanced Guide to TPA&quot;, appfiles_dir) } 4.3 Converting the original datasets This code chunk can be a bit obscure. It is only shown to make all of my steps transparent. # these packages are only used to import the data library(haven) library(stringr) library(janitor) library(purrr) try(dir.create(&quot;data-tsv&quot;)) ## Warning in dir.create(&quot;data-tsv&quot;): &#39;data-tsv&#39; already exists dta_files &lt;- list.files(&quot;00-application-files&quot;, pattern = &quot;dta&quot;, full.names = TRUE, recursive = TRUE) read_and_clean &lt;- function(finp) { message(finp) fout &lt;- finp %&gt;% str_replace(appfiles_dir, &quot;&quot;) %&gt;% str_replace(&quot;Chapter&quot;, &quot;ch&quot;) %&gt;% str_replace_all(&quot;Chapter[0-9]|\\\\.dta&quot;, &quot;&quot;) fout &lt;- fout %&gt;% str_replace_all(&quot;(/)&quot;, &quot;_&quot;) %&gt;% make_clean_names() long_names &lt;- c( &quot;datasets_&quot;, &quot;applications_&quot;, &quot;exercises_&quot;, &quot;1_trade_without_border_results_1&quot;, &quot;2_rt_as_effects_results_2_&quot; ) fout &lt;- fout %&gt;% str_replace_all(paste(long_names, collapse = &quot;|&quot;), &quot;&quot;) fout &lt;- str_replace(fout, &quot;_([0-9])_|__&quot;, &quot;_&quot;) fout2 &lt;- sprintf(&quot;data-tsv/%s.tsv&quot;, fout) if (!file.exists(fout2)) { d &lt;- read_dta(finp) %&gt;% clean_names() data.table::fwrite(d, fout2, sep = &quot;\\t&quot;) } } map(dta_files, read_and_clean) "],
["references.html", "References", " References "]
]
